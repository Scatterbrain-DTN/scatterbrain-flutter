// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.10.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../../frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `fmt`, `fmt`, `fmt`, `fmt`, `from`, `try_from`, `try_from`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `print_output`, `print_output`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<SbResult < String >>>
abstract class SbResultString implements RustOpaqueInterface {}

abstract class PrettyPrint {
  Future<SbResultString> printOutput();
}

class Identity {
  final UuidValue? fingerprint;
  final String name;
  final Uint8List publicKey;
  final bool isOwned;
  final Map<String, Uint8List> extra;
  final Uint8List sig;

  const Identity({
    this.fingerprint,
    required this.name,
    required this.publicKey,
    required this.isOwned,
    required this.extra,
    required this.sig,
  });

  @override
  int get hashCode =>
      fingerprint.hashCode ^
      name.hashCode ^
      publicKey.hashCode ^
      isOwned.hashCode ^
      extra.hashCode ^
      sig.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Identity &&
          runtimeType == other.runtimeType &&
          fingerprint == other.fingerprint &&
          name == other.name &&
          publicKey == other.publicKey &&
          isOwned == other.isOwned &&
          extra == other.extra &&
          sig == other.sig;
}

class Message {
  final UuidValue? fromFingerprint;
  final UuidValue? toFingerprint;
  final String application;
  final String extension_;
  final String mime;
  final PlatformInt64 sendDate;
  final PlatformInt64 receiveDate;
  final bool isFile;
  final UuidValue? id;
  final Uint8List body;
  final String fileName;

  const Message({
    this.fromFingerprint,
    this.toFingerprint,
    required this.application,
    required this.extension_,
    required this.mime,
    required this.sendDate,
    required this.receiveDate,
    required this.isFile,
    this.id,
    required this.body,
    required this.fileName,
  });

  static Future<Message> fromVec(
          {required List<int> body, required String application}) =>
      RustLib.instance.api.scatterbrainApiResponseMessageFromVec(
          body: body, application: application);

  @override
  int get hashCode =>
      fromFingerprint.hashCode ^
      toFingerprint.hashCode ^
      application.hashCode ^
      extension_.hashCode ^
      mime.hashCode ^
      sendDate.hashCode ^
      receiveDate.hashCode ^
      isFile.hashCode ^
      id.hashCode ^
      body.hashCode ^
      fileName.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Message &&
          runtimeType == other.runtimeType &&
          fromFingerprint == other.fromFingerprint &&
          toFingerprint == other.toFingerprint &&
          application == other.application &&
          extension_ == other.extension_ &&
          mime == other.mime &&
          sendDate == other.sendDate &&
          receiveDate == other.receiveDate &&
          isFile == other.isFile &&
          id == other.id &&
          body == other.body &&
          fileName == other.fileName;
}
