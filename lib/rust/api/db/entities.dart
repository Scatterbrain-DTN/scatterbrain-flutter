// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import '../../frb_generated.dart';
import '../../third_party/scatterbrain/api/response.dart';
import 'connection.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';

// These functions are ignored because they are not marked as `pub`: `compat_post_id`, `from_proto`, `from_proto`, `from_proto`, `to_proto`, `to_proto`
// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `fmt`
// These functions are ignored (category: IgnoreBecauseExplicitAttribute): `from_row`, `from_row`, `from_row`, `from_row`, `from_row`, `from_row`, `from_rows`, `from_rows`, `from_rows`, `from_rows`, `from_rows`, `from_rows`, `get_params`, `get_params`, `get_params`, `get_params`, `get_params`, `get_params`
// These functions are ignored (category: IgnoreBecauseNotAllowedOwner): `from_row`, `from_row`, `from_rows`, `from_rows`, `is_entity`, `is_entity`

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<NewsGroup>>
abstract class NewsGroup
    implements RustOpaqueInterface, Crud, FromRow, GetParams {
  Parent asParent();

  String get description;

  String get groupName;

  UuidValue? get parent;

  Uint8List? get parentHash;

  bool get sent;

  UuidValue get uuid;

  set description(String description);

  set groupName(String groupName);

  set parent(UuidValue? parent);

  set parentHash(Uint8List? parentHash);

  set sent(bool sent);

  set uuid(UuidValue uuid);

  @override
  Future<void> delete({required SubrosaDb conn});

  static Future<bool> hasParams() =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupHasParams();

  Future<Uint8List> hash();

  @override
  Future<void> insert({required SubrosaDb conn});

  @override
  Future<void> insertOnConflict(
      {required SubrosaDb conn, required OnConflict onConflict});

  static Future<bool> isEntity() =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupIsEntity();

  factory NewsGroup(
          {required UuidValue uuid,
          required String description,
          Parent? parent,
          required String groupName,
          required bool sent}) =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupNew(
          uuid: uuid,
          description: description,
          parent: parent,
          groupName: groupName,
          sent: sent);

  @override
  Future<void> update({required SubrosaDb conn});
}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Parent>>
abstract class Parent implements RustOpaqueInterface {}

// Rust type: RustOpaqueMoi<flutter_rust_bridge::for_generated::RustAutoOpaqueInner<Value>>
abstract class Value implements RustOpaqueInterface {}

abstract class FromRow {}

abstract class GetParams {}

abstract class SubrosaDao {
  Future<void> deleteGroup({required UuidValue uuid});

  Future<void> deletePost({required UuidValue uuid});

  Future<List<User>> getAllUsers();

  Future<List<User>> getAllUsersByOwnership({required bool owned});

  Future<NewsGroup?> getGroup({required UuidValue uuid});

  Future<List<NewsGroup>> getGroupsForParent({required UuidValue parent});

  Future<CachedIdentity> getIdentity({required UuidValue uuid});

  Future<DateTime?> getLastSyncDate();

  Future<List<NewsGroup>> getParents({required UuidValue group});

  Future<List<Posts>> getPosts({required UuidValue parent});

  Future<List<PostWithIdentity>> getPostsWithIdentity(
      {required UuidValue parent});

  Future<List<NewsGroup>> getRootGroups();

  Future<PlatformInt64> getTotalPosts({required UuidValue group});

  Future<List<NewsGroup>> getUnsentGroups();

  Future<List<Posts>> getUnsentPosts();

  Future<User?> getUser({required UuidValue identity});

  Future<void> markSentGroups({required List<Value> ids});

  Future<void> markSentPosts({required List<Value> ids});
}

abstract class TestDao {
  Future<List<NewsGroup>> test({required UuidValue uuid});

  Future<NewsGroup?> testNullable();

  Future<NewsGroup> testOne();
}

class CachedIdentity {
  final UuidValue uuid;
  final UuidValue? fingerprint;
  final String? userName;
  final String? bio;
  final bool? owned;
  final Uint8List? imageBytes;

  const CachedIdentity({
    required this.uuid,
    this.fingerprint,
    this.userName,
    this.bio,
    this.owned,
    this.imageBytes,
  });

  Future<void> delete({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesCachedIdentityDelete(that: this, conn: conn);

  static Future<bool> hasParams() =>
      RustLib.instance.api.crateApiDbEntitiesCachedIdentityHasParams();

  Future<void> insert({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesCachedIdentityInsert(that: this, conn: conn);

  Future<void> insertOnConflict(
          {required SubrosaDb conn, required OnConflict onConflict}) =>
      RustLib.instance.api.crateApiDbEntitiesCachedIdentityInsertOnConflict(
          that: this, conn: conn, onConflict: onConflict);

  static Future<bool> isEntity() =>
      RustLib.instance.api.crateApiDbEntitiesCachedIdentityIsEntity();

  Future<void> update({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesCachedIdentityUpdate(that: this, conn: conn);

  @override
  int get hashCode =>
      uuid.hashCode ^
      fingerprint.hashCode ^
      userName.hashCode ^
      bio.hashCode ^
      owned.hashCode ^
      imageBytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is CachedIdentity &&
          runtimeType == other.runtimeType &&
          uuid == other.uuid &&
          fingerprint == other.fingerprint &&
          userName == other.userName &&
          bio == other.bio &&
          owned == other.owned &&
          imageBytes == other.imageBytes;
}

class PostWithIdentity {
  final String? author;
  final String? header;
  final String? body;
  final Uint8List? sig;
  final DateTime receiveDate;
  final UuidValue postId;
  final UuidValue? identity;
  final UuidValue parentGroup;
  final bool sent;
  final UuidValue? fingerprint;
  final String? userName;
  final String? bio;
  final bool? owned;
  final Uint8List? imageBytes;

  const PostWithIdentity({
    this.author,
    this.header,
    this.body,
    this.sig,
    required this.receiveDate,
    required this.postId,
    this.identity,
    required this.parentGroup,
    required this.sent,
    this.fingerprint,
    this.userName,
    this.bio,
    this.owned,
    this.imageBytes,
  });

  Future<void> delete({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesPostWithIdentityDelete(that: this, conn: conn);

  static Future<bool> hasParams() =>
      RustLib.instance.api.crateApiDbEntitiesPostWithIdentityHasParams();

  Future<void> insert({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesPostWithIdentityInsert(that: this, conn: conn);

  Future<void> insertOnConflict(
          {required SubrosaDb conn, required OnConflict onConflict}) =>
      RustLib.instance.api.crateApiDbEntitiesPostWithIdentityInsertOnConflict(
          that: this, conn: conn, onConflict: onConflict);

  static Future<bool> isEntity() =>
      RustLib.instance.api.crateApiDbEntitiesPostWithIdentityIsEntity();

  Future<void> update({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesPostWithIdentityUpdate(that: this, conn: conn);

  @override
  int get hashCode =>
      author.hashCode ^
      header.hashCode ^
      body.hashCode ^
      sig.hashCode ^
      receiveDate.hashCode ^
      postId.hashCode ^
      identity.hashCode ^
      parentGroup.hashCode ^
      sent.hashCode ^
      fingerprint.hashCode ^
      userName.hashCode ^
      bio.hashCode ^
      owned.hashCode ^
      imageBytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is PostWithIdentity &&
          runtimeType == other.runtimeType &&
          author == other.author &&
          header == other.header &&
          body == other.body &&
          sig == other.sig &&
          receiveDate == other.receiveDate &&
          postId == other.postId &&
          identity == other.identity &&
          parentGroup == other.parentGroup &&
          sent == other.sent &&
          fingerprint == other.fingerprint &&
          userName == other.userName &&
          bio == other.bio &&
          owned == other.owned &&
          imageBytes == other.imageBytes;
}

class Posts {
  final String? header;
  final String? body;
  final Uint8List? sig;
  final DateTime receiveDate;
  final UuidValue postId;
  final UuidValue? identity;
  final UuidValue parentGroup;
  final bool sent;

  const Posts.raw({
    this.header,
    this.body,
    this.sig,
    required this.receiveDate,
    required this.postId,
    this.identity,
    required this.parentGroup,
    required this.sent,
  });

  Future<void> delete({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesPostsDelete(that: this, conn: conn);

  static Future<bool> hasParams() =>
      RustLib.instance.api.crateApiDbEntitiesPostsHasParams();

  Future<void> insert({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesPostsInsert(that: this, conn: conn);

  Future<void> insertOnConflict(
          {required SubrosaDb conn, required OnConflict onConflict}) =>
      RustLib.instance.api.crateApiDbEntitiesPostsInsertOnConflict(
          that: this, conn: conn, onConflict: onConflict);

  static Future<bool> isEntity() =>
      RustLib.instance.api.crateApiDbEntitiesPostsIsEntity();

  factory Posts(
          {required String header,
          required String body,
          required UuidValue group}) =>
      RustLib.instance.api
          .crateApiDbEntitiesPostsNew(header: header, body: body, group: group);

  static Posts newIdentity(
          {required String header,
          required String body,
          required Identity author,
          required UuidValue group}) =>
      RustLib.instance.api.crateApiDbEntitiesPostsNewIdentity(
          header: header, body: body, author: author, group: group);

  Future<void> update({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesPostsUpdate(that: this, conn: conn);

  @override
  int get hashCode =>
      header.hashCode ^
      body.hashCode ^
      sig.hashCode ^
      receiveDate.hashCode ^
      postId.hashCode ^
      identity.hashCode ^
      parentGroup.hashCode ^
      sent.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is Posts &&
          runtimeType == other.runtimeType &&
          header == other.header &&
          body == other.body &&
          sig == other.sig &&
          receiveDate == other.receiveDate &&
          postId == other.postId &&
          identity == other.identity &&
          parentGroup == other.parentGroup &&
          sent == other.sent;
}

class User {
  final UuidValue identity;
  final String userName;
  final String bio;
  final bool owned;
  final Uint8List imageBytes;

  const User({
    required this.identity,
    required this.userName,
    required this.bio,
    required this.owned,
    required this.imageBytes,
  });

  Future<void> delete({required SubrosaDb conn}) =>
      RustLib.instance.api.crateApiDbEntitiesUserDelete(that: this, conn: conn);

  static Future<bool> hasParams() =>
      RustLib.instance.api.crateApiDbEntitiesUserHasParams();

  Future<void> insert({required SubrosaDb conn}) =>
      RustLib.instance.api.crateApiDbEntitiesUserInsert(that: this, conn: conn);

  Future<void> insertOnConflict(
          {required SubrosaDb conn, required OnConflict onConflict}) =>
      RustLib.instance.api.crateApiDbEntitiesUserInsertOnConflict(
          that: this, conn: conn, onConflict: onConflict);

  static Future<bool> isEntity() =>
      RustLib.instance.api.crateApiDbEntitiesUserIsEntity();

  Future<void> update({required SubrosaDb conn}) =>
      RustLib.instance.api.crateApiDbEntitiesUserUpdate(that: this, conn: conn);

  @override
  int get hashCode =>
      identity.hashCode ^
      userName.hashCode ^
      bio.hashCode ^
      owned.hashCode ^
      imageBytes.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is User &&
          runtimeType == other.runtimeType &&
          identity == other.identity &&
          userName == other.userName &&
          bio == other.bio &&
          owned == other.owned &&
          imageBytes == other.imageBytes;
}
