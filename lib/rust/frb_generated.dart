// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.7.0.

// ignore_for_file: unused_import, unused_element, unnecessary_import, duplicate_ignore, invalid_use_of_internal_member, annotate_overrides, non_constant_identifier_names, curly_braces_in_flow_control_structures, prefer_const_literals_to_create_immutables, unused_field

import 'api.dart';
import 'api/db/connection.dart';
import 'api/db/entities.dart';
import 'api/db/migrations.dart';
import 'api/db/sync.dart';
import 'api/net.dart';
import 'api/proto.dart';
import 'api/proto/ser.dart';
import 'dart:async';
import 'dart:convert';
import 'frb_generated.dart';
import 'frb_generated.io.dart'
    if (dart.library.js_interop) 'frb_generated.web.dart';
import 'lib.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';
import 'package:uuid/uuid.dart';
import 'third_party/scatterbrain/api/api.dart';
import 'third_party/scatterbrain/api/error.dart';
import 'third_party/scatterbrain/api/mdns.dart';
import 'third_party/scatterbrain/api/mirror.dart';
import 'third_party/scatterbrain/api/response.dart';
import 'third_party/scatterbrain/api/types.dart';

/// Main entrypoint of the Rust API
class RustLib extends BaseEntrypoint<RustLibApi, RustLibApiImpl, RustLibWire> {
  @internal
  static final instance = RustLib._();

  RustLib._();

  /// Initialize flutter_rust_bridge
  static Future<void> init({
    RustLibApi? api,
    BaseHandler? handler,
    ExternalLibrary? externalLibrary,
  }) async {
    await instance.initImpl(
      api: api,
      handler: handler,
      externalLibrary: externalLibrary,
    );
  }

  /// Initialize flutter_rust_bridge in mock mode.
  /// No libraries for FFI are loaded.
  static void initMock({
    required RustLibApi api,
  }) {
    instance.initMockImpl(
      api: api,
    );
  }

  /// Dispose flutter_rust_bridge
  ///
  /// The call to this function is optional, since flutter_rust_bridge (and everything else)
  /// is automatically disposed when the app stops.
  static void dispose() => instance.disposeImpl();

  @override
  ApiImplConstructor<RustLibApiImpl, RustLibWire> get apiImplConstructor =>
      RustLibApiImpl.new;

  @override
  WireConstructor<RustLibWire> get wireConstructor =>
      RustLibWire.fromExternalLibrary;

  @override
  Future<void> executeRustInitializers() async {}

  @override
  ExternalLibraryLoaderConfig get defaultExternalLibraryLoaderConfig =>
      kDefaultExternalLibraryLoaderConfig;

  @override
  String get codegenVersion => '2.7.0';

  @override
  int get rustContentHash => 2116967851;

  static const kDefaultExternalLibraryLoaderConfig =
      ExternalLibraryLoaderConfig(
    stem: 'scatterbrain_flutter',
    ioDirectory: 'rust/target/release/',
    webPrefix: 'pkg/',
  );
}

abstract class RustLibApi extends BaseApi {
  Future<SbSession?> scatterbrainApiMdnsHostRecordConnect(
      {required HostRecord that, required CryptoConfig state});

  List<IpAddr> scatterbrainApiMdnsHostRecordGetAddrs(
      {required HostRecord that});

  String scatterbrainApiMdnsHostRecordGetName({required HostRecord that});

  int scatterbrainApiMdnsHostRecordGetPort({required HostRecord that});

  Future<SbSession> scatterbrainApiMdnsHostRecordPair(
      {required HostRecord that,
      required CryptoConfig state,
      required String appName,
      required FutureOr<bool> Function(List<String>) cb});

  Future<PairStatus> scatterbrainApiMdnsHostRecordTryPair(
      {required HostRecord that,
      required CryptoConfig state,
      required String appName,
      required FutureOr<void> Function(SbSession?) onConnect});

  Future<bool> scatterbrainApiMdnsIpv4AddrIsLoopback({required Ipv4Addr that});

  Future<bool> scatterbrainApiMdnsIpv4AddrIsMulticast({required Ipv4Addr that});

  Future<bool> scatterbrainApiMdnsIpv4AddrIsUnspecified(
      {required Ipv4Addr that});

  String scatterbrainApiMdnsIpv4AddrToString({required Ipv4Addr that});

  Future<bool> scatterbrainApiMdnsIpv6AddrIsLoopback({required Ipv6Addr that});

  Future<bool> scatterbrainApiMdnsIpv6AddrIsMulticast({required Ipv6Addr that});

  Future<bool> scatterbrainApiMdnsIpv6AddrIsUnspecified(
      {required Ipv6Addr that});

  String scatterbrainApiMdnsIpv6AddrToString({required Ipv6Addr that});

  Parent crateApiDbEntitiesNewsGroupAsParent({required NewsGroup that});

  String crateApiDbEntitiesNewsGroupAutoAccessorGetDescription(
      {required NewsGroup that});

  String crateApiDbEntitiesNewsGroupAutoAccessorGetGroupName(
      {required NewsGroup that});

  UuidValue? crateApiDbEntitiesNewsGroupAutoAccessorGetParent(
      {required NewsGroup that});

  Uint8List? crateApiDbEntitiesNewsGroupAutoAccessorGetParentHash(
      {required NewsGroup that});

  bool crateApiDbEntitiesNewsGroupAutoAccessorGetSent(
      {required NewsGroup that});

  UuidValue crateApiDbEntitiesNewsGroupAutoAccessorGetUuid(
      {required NewsGroup that});

  void crateApiDbEntitiesNewsGroupAutoAccessorSetDescription(
      {required NewsGroup that, required String description});

  void crateApiDbEntitiesNewsGroupAutoAccessorSetGroupName(
      {required NewsGroup that, required String groupName});

  void crateApiDbEntitiesNewsGroupAutoAccessorSetParent(
      {required NewsGroup that, UuidValue? parent});

  void crateApiDbEntitiesNewsGroupAutoAccessorSetParentHash(
      {required NewsGroup that, Uint8List? parentHash});

  void crateApiDbEntitiesNewsGroupAutoAccessorSetSent(
      {required NewsGroup that, required bool sent});

  void crateApiDbEntitiesNewsGroupAutoAccessorSetUuid(
      {required NewsGroup that, required UuidValue uuid});

  Future<void> crateApiDbEntitiesNewsGroupDelete(
      {required NewsGroup that, required SubrosaDb conn});

  Future<bool> crateApiDbEntitiesNewsGroupHasParams();

  Future<Uint8List> crateApiDbEntitiesNewsGroupHash({required NewsGroup that});

  Future<void> crateApiDbEntitiesNewsGroupInsert(
      {required NewsGroup that, required SubrosaDb conn});

  Future<void> crateApiDbEntitiesNewsGroupInsertOnConflict(
      {required NewsGroup that,
      required SubrosaDb conn,
      required OnConflict onConflict});

  Future<bool> crateApiDbEntitiesNewsGroupIsEntity();

  NewsGroup crateApiDbEntitiesNewsGroupNew(
      {required UuidValue uuid,
      required String description,
      Parent? parent,
      required String groupName,
      required bool sent});

  Future<void> crateApiDbEntitiesNewsGroupUpdate(
      {required NewsGroup that, required SubrosaDb conn});

  List<String> scatterbrainApiApiPairingSessionAutoAccessorGetCoin(
      {required PairingSession that});

  UuidValue scatterbrainApiApiPairingSessionAutoAccessorGetSession(
      {required PairingSession that});

  void scatterbrainApiApiPairingSessionAutoAccessorSetCoin(
      {required PairingSession that, required List<String> coin});

  void scatterbrainApiApiPairingSessionAutoAccessorSetSession(
      {required PairingSession that, required UuidValue session});

  Future<PairResult> scatterbrainApiApiPairingSessionTryPairConfirm(
      {required PairingSession that, required bool accept});

  Future<void> scatterbrainApiApiSbSessionDisconnect({required SbSession that});

  Future<List<SbEvent>> scatterbrainApiApiSbSessionGetEvents(
      {required SbSession that, required bool block, int? count});

  Future<List<Identity>> scatterbrainApiApiSbSessionGetIdentity(
      {required SbSession that, UuidValue? id});

  Future<List<Message>> scatterbrainApiApiSbSessionGetMessages(
      {required SbSession that, required String application, int? limit});

  Future<List<Message>> scatterbrainApiApiSbSessionGetMessagesRecieveDate(
      {required SbSession that,
      required String application,
      int? limit,
      DateTime? startDate,
      DateTime? endDate});

  Future<List<Message>> scatterbrainApiApiSbSessionGetMessagesSendDate(
      {required SbSession that,
      required String application,
      int? limit,
      DateTime? startDate,
      DateTime? endDate});

  Future<ImportIdentityState> scatterbrainApiApiSbSessionInitiateIdentityImport(
      {required SbSession that, UuidValue? id});

  Future<bool> scatterbrainApiApiSbSessionIsClosed({required SbSession that});

  Future<void> scatterbrainApiApiSbSessionOnConnect({required SbSession that});

  Future<void> scatterbrainApiApiSbSessionSendMessages(
      {required SbSession that,
      required List<Message> messages,
      UuidValue? signIdentity});

  Future<void> scatterbrainApiApiSbSessionSendNewsgroup(
      {required SbSession that, required NewsGroup newsgroup});

  Future<void> scatterbrainApiApiSbSessionSendPost(
      {required SbSession that, required Posts post, required SubrosaDb db});

  Future<void> scatterbrainApiApiSbSessionSetOnConnect(
      {required SbSession that,
      required FutureOr<void> Function(SbSession?) onConnect});

  Future<void> scatterbrainApiMdnsServiceScannerDiscoverDevices(
      {required ServiceScanner that,
      required FutureOr<void> Function(List<HostRecord>) cb});

  ServiceScanner scatterbrainApiMdnsServiceScannerNew();

  Future<void> scatterbrainApiMdnsServiceScannerStopScan(
      {required ServiceScanner that});

  Future<void> crateApiDbConnectionSubrosaDbDeleteGroup(
      {required SubrosaDb that, required UuidValue uuid});

  Future<void> crateApiDbConnectionSubrosaDbDeletePost(
      {required SubrosaDb that, required UuidValue uuid});

  Future<List<User>> crateApiDbConnectionSubrosaDbGetAllUsers(
      {required SubrosaDb that});

  Future<List<User>> crateApiDbConnectionSubrosaDbGetAllUsersByOwnership(
      {required SubrosaDb that, required bool owned});

  Future<void> crateApiDbConnectionSubrosaDbGetConnection(
      {required SubrosaDb that});

  Future<NewsGroup?> crateApiDbConnectionSubrosaDbGetGroup(
      {required SubrosaDb that, required UuidValue uuid});

  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbGetGroupsForParent(
      {required SubrosaDb that, required UuidValue parent});

  Future<CachedIdentity> crateApiDbConnectionSubrosaDbGetIdentity(
      {required SubrosaDb that, required UuidValue uuid});

  Future<DateTime?> crateApiDbConnectionSubrosaDbGetLastSyncDate(
      {required SubrosaDb that});

  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbGetParents(
      {required SubrosaDb that, required UuidValue group});

  Future<List<Posts>> crateApiDbConnectionSubrosaDbGetPosts(
      {required SubrosaDb that, required UuidValue parent});

  Future<List<PostWithIdentity>>
      crateApiDbConnectionSubrosaDbGetPostsWithIdentity(
          {required SubrosaDb that, required UuidValue parent});

  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbGetRootGroups(
      {required SubrosaDb that});

  Future<PlatformInt64> crateApiDbConnectionSubrosaDbGetTotalPosts(
      {required SubrosaDb that, required UuidValue group});

  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbGetUnsentGroups(
      {required SubrosaDb that});

  Future<List<Posts>> crateApiDbConnectionSubrosaDbGetUnsentPosts(
      {required SubrosaDb that});

  Future<User?> crateApiDbConnectionSubrosaDbGetUser(
      {required SubrosaDb that, required UuidValue identity});

  Watcher crateApiDbConnectionSubrosaDbGetWatcher({required SubrosaDb that});

  Future<void> crateApiDbConnectionSubrosaDbInsertGroup(
      {required SubrosaDb that, required NewsGroup group});

  Future<void> crateApiDbConnectionSubrosaDbInsertMessage(
      {required SubrosaDb that, required Message message});

  Future<void> crateApiDbConnectionSubrosaDbMarkSentGroups(
      {required SubrosaDb that, required List<Value> ids});

  Future<void> crateApiDbConnectionSubrosaDbMarkSentPosts(
      {required SubrosaDb that, required List<Value> ids});

  SubrosaDb crateApiDbConnectionSubrosaDbNew({required String path});

  SubrosaDb crateApiDbConnectionSubrosaDbNewInMemory();

  Future<void> crateApiDbConnectionSubrosaDbProcessScatterMessages(
      {required SubrosaDb that, required List<Message> messages});

  Future<void> crateApiDbConnectionSubrosaDbSync(
      {required SubrosaDb that, required SbSession sbConnection});

  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbTest(
      {required SubrosaDb that, required UuidValue uuid});

  Future<NewsGroup?> crateApiDbConnectionSubrosaDbTestNullable(
      {required SubrosaDb that});

  Future<NewsGroup> crateApiDbConnectionSubrosaDbTestOne(
      {required SubrosaDb that});

  Future<Message> crateApiProtoSerSubrosaMessageGetMessage(
      {required SubrosaMessage that});

  SubrosaMessage crateApiProtoSerSubrosaMessageHandleSubrosaMessage(
      {required Message sbMessage});

  Future<void> crateApiDbConnectionWatcherWatch(
      {required Watcher that,
      required String table,
      required FutureOr<void> Function(SubrosaDb) cb});

  Future<void> crateApiDbEntitiesCachedIdentityDelete(
      {required CachedIdentity that, required SubrosaDb conn});

  Future<bool> crateApiDbEntitiesCachedIdentityHasParams();

  Future<void> crateApiDbEntitiesCachedIdentityInsert(
      {required CachedIdentity that, required SubrosaDb conn});

  Future<void> crateApiDbEntitiesCachedIdentityInsertOnConflict(
      {required CachedIdentity that,
      required SubrosaDb conn,
      required OnConflict onConflict});

  Future<bool> crateApiDbEntitiesCachedIdentityIsEntity();

  Future<void> crateApiDbEntitiesCachedIdentityUpdate(
      {required CachedIdentity that, required SubrosaDb conn});

  Future<void> crateApiDbSyncConnTest({required SbSession session});

  Future<CryptoConfig> scatterbrainApiTypesCryptoConfigGenerate();

  Future<void> crateApiInitLogging();

  Future<Message> scatterbrainApiResponseMessageFromVec(
      {required List<int> body, required String application});

  Future<void> crateApiDbEntitiesPostWithIdentityDelete(
      {required PostWithIdentity that, required SubrosaDb conn});

  Future<bool> crateApiDbEntitiesPostWithIdentityHasParams();

  Future<void> crateApiDbEntitiesPostWithIdentityInsert(
      {required PostWithIdentity that, required SubrosaDb conn});

  Future<void> crateApiDbEntitiesPostWithIdentityInsertOnConflict(
      {required PostWithIdentity that,
      required SubrosaDb conn,
      required OnConflict onConflict});

  Future<bool> crateApiDbEntitiesPostWithIdentityIsEntity();

  Future<void> crateApiDbEntitiesPostWithIdentityUpdate(
      {required PostWithIdentity that, required SubrosaDb conn});

  Future<void> crateApiDbEntitiesPostsDelete(
      {required Posts that, required SubrosaDb conn});

  Future<bool> crateApiDbEntitiesPostsHasParams();

  Future<void> crateApiDbEntitiesPostsInsert(
      {required Posts that, required SubrosaDb conn});

  Future<void> crateApiDbEntitiesPostsInsertOnConflict(
      {required Posts that,
      required SubrosaDb conn,
      required OnConflict onConflict});

  Future<bool> crateApiDbEntitiesPostsIsEntity();

  Posts crateApiDbEntitiesPostsNew(
      {required String header, required String body, required UuidValue group});

  Posts crateApiDbEntitiesPostsNewIdentity(
      {required String header,
      required String body,
      required Identity author,
      required UuidValue group});

  Future<void> crateApiDbEntitiesPostsUpdate(
      {required Posts that, required SubrosaDb conn});

  Future<void> crateApiDbMigrationsRunMigrations({required SubrosaDb conn});

  Future<void> crateApiDbEntitiesUserDelete(
      {required User that, required SubrosaDb conn});

  Future<bool> crateApiDbEntitiesUserHasParams();

  Future<void> crateApiDbEntitiesUserInsert(
      {required User that, required SubrosaDb conn});

  Future<void> crateApiDbEntitiesUserInsertOnConflict(
      {required User that,
      required SubrosaDb conn,
      required OnConflict onConflict});

  Future<bool> crateApiDbEntitiesUserIsEntity();

  Future<void> crateApiDbEntitiesUserUpdate(
      {required User that, required SubrosaDb conn});

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DartSyncFutureSbResultSbSession;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DartSyncFutureSbResultSbSession;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_DartSyncFutureSbResultSbSessionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_HostRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_HostRecord;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_HostRecordPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Ipv4Addr;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Ipv4Addr;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_Ipv4AddrPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Ipv6Addr;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Ipv6Addr;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_Ipv6AddrPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MessageType;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MessageType;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_MessageTypePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NewsGroup;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NewsGroup;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_NewsGroupPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_PairingSession;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_PairingSession;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_PairingSessionPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Parent;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Parent;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ParentPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtoUuid;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtoUuid;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ProtoUuidPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_SbEvent;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_SbEvent;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SbEventPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SbResult;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SbResult;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SbResultPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SbResultString;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SbResultString;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SbResultStringPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SbSession;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SbSession;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SbSessionPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ServiceScanner;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ServiceScanner;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_ServiceScannerPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubrosaDb;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubrosaDb;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_SubrosaDbPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubrosaMessage;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubrosaMessage;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_SubrosaMessagePtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_TryPairConfirm;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_TryPairConfirm;

  CrossPlatformFinalizerArg
      get rust_arc_decrement_strong_count_TryPairConfirmPtr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_TypePrefix;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_TypePrefix;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_TypePrefixPtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Value;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Value;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_ValuePtr;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Watcher;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Watcher;

  CrossPlatformFinalizerArg get rust_arc_decrement_strong_count_WatcherPtr;
}

class RustLibApiImpl extends RustLibApiImplPlatform implements RustLibApi {
  RustLibApiImpl({
    required super.handler,
    required super.wire,
    required super.generalizedFrbRustBinding,
    required super.portManager,
  });

  @override
  Future<SbSession?> scatterbrainApiMdnsHostRecordConnect(
      {required HostRecord that, required CryptoConfig state}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
            that, serializer);
        sse_encode_box_autoadd_crypto_config(state, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 1, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiMdnsHostRecordConnectConstMeta,
      argValues: [that, state],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsHostRecordConnectConstMeta =>
      const TaskConstMeta(
        debugName: "HostRecord_connect",
        argNames: ["that", "state"],
      );

  @override
  List<IpAddr> scatterbrainApiMdnsHostRecordGetAddrs(
      {required HostRecord that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 2)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_ip_addr,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsHostRecordGetAddrsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsHostRecordGetAddrsConstMeta =>
      const TaskConstMeta(
        debugName: "HostRecord_get_addrs",
        argNames: ["that"],
      );

  @override
  String scatterbrainApiMdnsHostRecordGetName({required HostRecord that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 3)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsHostRecordGetNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsHostRecordGetNameConstMeta =>
      const TaskConstMeta(
        debugName: "HostRecord_get_name",
        argNames: ["that"],
      );

  @override
  int scatterbrainApiMdnsHostRecordGetPort({required HostRecord that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 4)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_u_16,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsHostRecordGetPortConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsHostRecordGetPortConstMeta =>
      const TaskConstMeta(
        debugName: "HostRecord_get_port",
        argNames: ["that"],
      );

  @override
  Future<SbSession> scatterbrainApiMdnsHostRecordPair(
      {required HostRecord that,
      required CryptoConfig state,
      required String appName,
      required FutureOr<bool> Function(List<String>) cb}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
            that, serializer);
        sse_encode_box_autoadd_crypto_config(state, serializer);
        sse_encode_String(appName, serializer);
        sse_encode_DartFn_Inputs_list_String_Output_bool_AnyhowException(
            cb, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 5, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiMdnsHostRecordPairConstMeta,
      argValues: [that, state, appName, cb],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsHostRecordPairConstMeta =>
      const TaskConstMeta(
        debugName: "HostRecord_pair",
        argNames: ["that", "state", "appName", "cb"],
      );

  @override
  Future<PairStatus> scatterbrainApiMdnsHostRecordTryPair(
      {required HostRecord that,
      required CryptoConfig state,
      required String appName,
      required FutureOr<void> Function(SbSession?) onConnect}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
            that, serializer);
        sse_encode_box_autoadd_crypto_config(state, serializer);
        sse_encode_String(appName, serializer);
        sse_encode_DartFn_Inputs_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession_Output_unit_AnyhowException(
            onConnect, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 6, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_pair_status,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiMdnsHostRecordTryPairConstMeta,
      argValues: [that, state, appName, onConnect],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsHostRecordTryPairConstMeta =>
      const TaskConstMeta(
        debugName: "HostRecord_try_pair",
        argNames: ["that", "state", "appName", "onConnect"],
      );

  @override
  Future<bool> scatterbrainApiMdnsIpv4AddrIsLoopback({required Ipv4Addr that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 7, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsIpv4AddrIsLoopbackConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsIpv4AddrIsLoopbackConstMeta =>
      const TaskConstMeta(
        debugName: "Ipv4Addr_is_loopback",
        argNames: ["that"],
      );

  @override
  Future<bool> scatterbrainApiMdnsIpv4AddrIsMulticast(
      {required Ipv4Addr that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 8, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsIpv4AddrIsMulticastConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsIpv4AddrIsMulticastConstMeta =>
      const TaskConstMeta(
        debugName: "Ipv4Addr_is_multicast",
        argNames: ["that"],
      );

  @override
  Future<bool> scatterbrainApiMdnsIpv4AddrIsUnspecified(
      {required Ipv4Addr that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 9, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsIpv4AddrIsUnspecifiedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsIpv4AddrIsUnspecifiedConstMeta =>
      const TaskConstMeta(
        debugName: "Ipv4Addr_is_unspecified",
        argNames: ["that"],
      );

  @override
  String scatterbrainApiMdnsIpv4AddrToString({required Ipv4Addr that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 10)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsIpv4AddrToStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsIpv4AddrToStringConstMeta =>
      const TaskConstMeta(
        debugName: "Ipv4Addr_to_string",
        argNames: ["that"],
      );

  @override
  Future<bool> scatterbrainApiMdnsIpv6AddrIsLoopback({required Ipv6Addr that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 11, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsIpv6AddrIsLoopbackConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsIpv6AddrIsLoopbackConstMeta =>
      const TaskConstMeta(
        debugName: "Ipv6Addr_is_loopback",
        argNames: ["that"],
      );

  @override
  Future<bool> scatterbrainApiMdnsIpv6AddrIsMulticast(
      {required Ipv6Addr that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 12, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsIpv6AddrIsMulticastConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsIpv6AddrIsMulticastConstMeta =>
      const TaskConstMeta(
        debugName: "Ipv6Addr_is_multicast",
        argNames: ["that"],
      );

  @override
  Future<bool> scatterbrainApiMdnsIpv6AddrIsUnspecified(
      {required Ipv6Addr that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 13, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsIpv6AddrIsUnspecifiedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsIpv6AddrIsUnspecifiedConstMeta =>
      const TaskConstMeta(
        debugName: "Ipv6Addr_is_unspecified",
        argNames: ["that"],
      );

  @override
  String scatterbrainApiMdnsIpv6AddrToString({required Ipv6Addr that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 14)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsIpv6AddrToStringConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsIpv6AddrToStringConstMeta =>
      const TaskConstMeta(
        debugName: "Ipv6Addr_to_string",
        argNames: ["that"],
      );

  @override
  Parent crateApiDbEntitiesNewsGroupAsParent({required NewsGroup that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 15)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAsParentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAsParentConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_as_parent",
        argNames: ["that"],
      );

  @override
  String crateApiDbEntitiesNewsGroupAutoAccessorGetDescription(
      {required NewsGroup that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 16)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiDbEntitiesNewsGroupAutoAccessorGetDescriptionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesNewsGroupAutoAccessorGetDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "NewsGroup_auto_accessor_get_description",
            argNames: ["that"],
          );

  @override
  String crateApiDbEntitiesNewsGroupAutoAccessorGetGroupName(
      {required NewsGroup that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 17)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_String,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorGetGroupNameConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesNewsGroupAutoAccessorGetGroupNameConstMeta =>
          const TaskConstMeta(
            debugName: "NewsGroup_auto_accessor_get_group_name",
            argNames: ["that"],
          );

  @override
  UuidValue? crateApiDbEntitiesNewsGroupAutoAccessorGetParent(
      {required NewsGroup that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 18)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_Uuid,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorGetParentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesNewsGroupAutoAccessorGetParentConstMeta =>
          const TaskConstMeta(
            debugName: "NewsGroup_auto_accessor_get_parent",
            argNames: ["that"],
          );

  @override
  Uint8List? crateApiDbEntitiesNewsGroupAutoAccessorGetParentHash(
      {required NewsGroup that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 19)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorGetParentHashConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesNewsGroupAutoAccessorGetParentHashConstMeta =>
          const TaskConstMeta(
            debugName: "NewsGroup_auto_accessor_get_parent_hash",
            argNames: ["that"],
          );

  @override
  bool crateApiDbEntitiesNewsGroupAutoAccessorGetSent(
      {required NewsGroup that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 20)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorGetSentConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAutoAccessorGetSentConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_get_sent",
        argNames: ["that"],
      );

  @override
  UuidValue crateApiDbEntitiesNewsGroupAutoAccessorGetUuid(
      {required NewsGroup that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 21)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Uuid,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorGetUuidConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAutoAccessorGetUuidConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_get_uuid",
        argNames: ["that"],
      );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetDescription(
      {required NewsGroup that, required String description}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_String(description, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 22)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kCrateApiDbEntitiesNewsGroupAutoAccessorSetDescriptionConstMeta,
      argValues: [that, description],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesNewsGroupAutoAccessorSetDescriptionConstMeta =>
          const TaskConstMeta(
            debugName: "NewsGroup_auto_accessor_set_description",
            argNames: ["that", "description"],
          );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetGroupName(
      {required NewsGroup that, required String groupName}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_String(groupName, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 23)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorSetGroupNameConstMeta,
      argValues: [that, groupName],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesNewsGroupAutoAccessorSetGroupNameConstMeta =>
          const TaskConstMeta(
            debugName: "NewsGroup_auto_accessor_set_group_name",
            argNames: ["that", "groupName"],
          );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetParent(
      {required NewsGroup that, UuidValue? parent}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_opt_Uuid(parent, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 24)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorSetParentConstMeta,
      argValues: [that, parent],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesNewsGroupAutoAccessorSetParentConstMeta =>
          const TaskConstMeta(
            debugName: "NewsGroup_auto_accessor_set_parent",
            argNames: ["that", "parent"],
          );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetParentHash(
      {required NewsGroup that, Uint8List? parentHash}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_opt_list_prim_u_8_strict(parentHash, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 25)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorSetParentHashConstMeta,
      argValues: [that, parentHash],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesNewsGroupAutoAccessorSetParentHashConstMeta =>
          const TaskConstMeta(
            debugName: "NewsGroup_auto_accessor_set_parent_hash",
            argNames: ["that", "parentHash"],
          );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetSent(
      {required NewsGroup that, required bool sent}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_bool(sent, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 26)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorSetSentConstMeta,
      argValues: [that, sent],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAutoAccessorSetSentConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_set_sent",
        argNames: ["that", "sent"],
      );

  @override
  void crateApiDbEntitiesNewsGroupAutoAccessorSetUuid(
      {required NewsGroup that, required UuidValue uuid}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_Uuid(uuid, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 27)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupAutoAccessorSetUuidConstMeta,
      argValues: [that, uuid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupAutoAccessorSetUuidConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_auto_accessor_set_uuid",
        argNames: ["that", "uuid"],
      );

  @override
  Future<void> crateApiDbEntitiesNewsGroupDelete(
      {required NewsGroup that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 28, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupDeleteConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbEntitiesNewsGroupHasParams() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 29, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupHasParamsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupHasParamsConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_has_params",
        argNames: [],
      );

  @override
  Future<Uint8List> crateApiDbEntitiesNewsGroupHash({required NewsGroup that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 30, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_prim_u_8_strict,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupHashConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupHashConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_hash",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiDbEntitiesNewsGroupInsert(
      {required NewsGroup that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 31, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupInsertConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupInsertConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbEntitiesNewsGroupInsertOnConflict(
      {required NewsGroup that,
      required SubrosaDb conn,
      required OnConflict onConflict}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        sse_encode_on_conflict(onConflict, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 32, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupInsertOnConflictConstMeta,
      argValues: [that, conn, onConflict],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupInsertOnConflictConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_insert_on_conflict",
        argNames: ["that", "conn", "onConflict"],
      );

  @override
  Future<bool> crateApiDbEntitiesNewsGroupIsEntity() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 33, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupIsEntityConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupIsEntityConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_is_entity",
        argNames: [],
      );

  @override
  NewsGroup crateApiDbEntitiesNewsGroupNew(
      {required UuidValue uuid,
      required String description,
      Parent? parent,
      required String groupName,
      required bool sent}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Uuid(uuid, serializer);
        sse_encode_String(description, serializer);
        sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
            parent, serializer);
        sse_encode_String(groupName, serializer);
        sse_encode_bool(sent, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 34)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupNewConstMeta,
      argValues: [uuid, description, parent, groupName, sent],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupNewConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_new",
        argNames: ["uuid", "description", "parent", "groupName", "sent"],
      );

  @override
  Future<void> crateApiDbEntitiesNewsGroupUpdate(
      {required NewsGroup that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 35, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesNewsGroupUpdateConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesNewsGroupUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "NewsGroup_update",
        argNames: ["that", "conn"],
      );

  @override
  List<String> scatterbrainApiApiPairingSessionAutoAccessorGetCoin(
      {required PairingSession that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 36)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_String,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiApiPairingSessionAutoAccessorGetCoinConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kScatterbrainApiApiPairingSessionAutoAccessorGetCoinConstMeta =>
          const TaskConstMeta(
            debugName: "PairingSession_auto_accessor_get_coin",
            argNames: ["that"],
          );

  @override
  UuidValue scatterbrainApiApiPairingSessionAutoAccessorGetSession(
      {required PairingSession that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 37)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_Uuid,
        decodeErrorData: null,
      ),
      constMeta:
          kScatterbrainApiApiPairingSessionAutoAccessorGetSessionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kScatterbrainApiApiPairingSessionAutoAccessorGetSessionConstMeta =>
          const TaskConstMeta(
            debugName: "PairingSession_auto_accessor_get_session",
            argNames: ["that"],
          );

  @override
  void scatterbrainApiApiPairingSessionAutoAccessorSetCoin(
      {required PairingSession that, required List<String> coin}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
            that, serializer);
        sse_encode_list_String(coin, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 38)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiApiPairingSessionAutoAccessorSetCoinConstMeta,
      argValues: [that, coin],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kScatterbrainApiApiPairingSessionAutoAccessorSetCoinConstMeta =>
          const TaskConstMeta(
            debugName: "PairingSession_auto_accessor_set_coin",
            argNames: ["that", "coin"],
          );

  @override
  void scatterbrainApiApiPairingSessionAutoAccessorSetSession(
      {required PairingSession that, required UuidValue session}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
            that, serializer);
        sse_encode_Uuid(session, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 39)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta:
          kScatterbrainApiApiPairingSessionAutoAccessorSetSessionConstMeta,
      argValues: [that, session],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kScatterbrainApiApiPairingSessionAutoAccessorSetSessionConstMeta =>
          const TaskConstMeta(
            debugName: "PairingSession_auto_accessor_set_session",
            argNames: ["that", "session"],
          );

  @override
  Future<PairResult> scatterbrainApiApiPairingSessionTryPairConfirm(
      {required PairingSession that, required bool accept}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
            that, serializer);
        sse_encode_bool(accept, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 40, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_pair_result,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiPairingSessionTryPairConfirmConstMeta,
      argValues: [that, accept],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiPairingSessionTryPairConfirmConstMeta =>
      const TaskConstMeta(
        debugName: "PairingSession_try_pair_confirm",
        argNames: ["that", "accept"],
      );

  @override
  Future<void> scatterbrainApiApiSbSessionDisconnect(
      {required SbSession that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 41, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiApiSbSessionDisconnectConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionDisconnectConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_disconnect",
        argNames: ["that"],
      );

  @override
  Future<List<SbEvent>> scatterbrainApiApiSbSessionGetEvents(
      {required SbSession that, required bool block, int? count}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_bool(block, serializer);
        sse_encode_opt_box_autoadd_u_32(count, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 42, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionGetEventsConstMeta,
      argValues: [that, block, count],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionGetEventsConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_get_events",
        argNames: ["that", "block", "count"],
      );

  @override
  Future<List<Identity>> scatterbrainApiApiSbSessionGetIdentity(
      {required SbSession that, UuidValue? id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_opt_Uuid(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 43, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_identity,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionGetIdentityConstMeta,
      argValues: [that, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionGetIdentityConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_get_identity",
        argNames: ["that", "id"],
      );

  @override
  Future<List<Message>> scatterbrainApiApiSbSessionGetMessages(
      {required SbSession that, required String application, int? limit}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_String(application, serializer);
        sse_encode_opt_box_autoadd_i_32(limit, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 44, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_message,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionGetMessagesConstMeta,
      argValues: [that, application, limit],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionGetMessagesConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_get_messages",
        argNames: ["that", "application", "limit"],
      );

  @override
  Future<List<Message>> scatterbrainApiApiSbSessionGetMessagesRecieveDate(
      {required SbSession that,
      required String application,
      int? limit,
      DateTime? startDate,
      DateTime? endDate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_String(application, serializer);
        sse_encode_opt_box_autoadd_i_32(limit, serializer);
        sse_encode_opt_box_autoadd_Chrono_Naive(startDate, serializer);
        sse_encode_opt_box_autoadd_Chrono_Naive(endDate, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 45, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_message,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionGetMessagesRecieveDateConstMeta,
      argValues: [that, application, limit, startDate, endDate],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kScatterbrainApiApiSbSessionGetMessagesRecieveDateConstMeta =>
          const TaskConstMeta(
            debugName: "SbSession_get_messages_recieve_date",
            argNames: ["that", "application", "limit", "startDate", "endDate"],
          );

  @override
  Future<List<Message>> scatterbrainApiApiSbSessionGetMessagesSendDate(
      {required SbSession that,
      required String application,
      int? limit,
      DateTime? startDate,
      DateTime? endDate}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_String(application, serializer);
        sse_encode_opt_box_autoadd_i_32(limit, serializer);
        sse_encode_opt_box_autoadd_Chrono_Naive(startDate, serializer);
        sse_encode_opt_box_autoadd_Chrono_Naive(endDate, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 46, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_message,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionGetMessagesSendDateConstMeta,
      argValues: [that, application, limit, startDate, endDate],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionGetMessagesSendDateConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_get_messages_send_date",
        argNames: ["that", "application", "limit", "startDate", "endDate"],
      );

  @override
  Future<ImportIdentityState> scatterbrainApiApiSbSessionInitiateIdentityImport(
      {required SbSession that, UuidValue? id}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_opt_Uuid(id, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 47, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_import_identity_state,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionInitiateIdentityImportConstMeta,
      argValues: [that, id],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kScatterbrainApiApiSbSessionInitiateIdentityImportConstMeta =>
          const TaskConstMeta(
            debugName: "SbSession_initiate_identity_import",
            argNames: ["that", "id"],
          );

  @override
  Future<bool> scatterbrainApiApiSbSessionIsClosed({required SbSession that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 48, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionIsClosedConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionIsClosedConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_is_closed",
        argNames: ["that"],
      );

  @override
  Future<void> scatterbrainApiApiSbSessionOnConnect({required SbSession that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 49, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiApiSbSessionOnConnectConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionOnConnectConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_on_connect",
        argNames: ["that"],
      );

  @override
  Future<void> scatterbrainApiApiSbSessionSendMessages(
      {required SbSession that,
      required List<Message> messages,
      UuidValue? signIdentity}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_list_message(messages, serializer);
        sse_encode_opt_Uuid(signIdentity, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 50, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionSendMessagesConstMeta,
      argValues: [that, messages, signIdentity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionSendMessagesConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_send_messages",
        argNames: ["that", "messages", "signIdentity"],
      );

  @override
  Future<void> scatterbrainApiApiSbSessionSendNewsgroup(
      {required SbSession that, required NewsGroup newsgroup}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            newsgroup, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 51, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionSendNewsgroupConstMeta,
      argValues: [that, newsgroup],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionSendNewsgroupConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_send_newsgroup",
        argNames: ["that", "newsgroup"],
      );

  @override
  Future<void> scatterbrainApiApiSbSessionSendPost(
      {required SbSession that, required Posts post, required SubrosaDb db}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_box_autoadd_posts(post, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            db, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 52, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiApiSbSessionSendPostConstMeta,
      argValues: [that, post, db],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionSendPostConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_send_post",
        argNames: ["that", "post", "db"],
      );

  @override
  Future<void> scatterbrainApiApiSbSessionSetOnConnect(
      {required SbSession that,
      required FutureOr<void> Function(SbSession?) onConnect}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            that, serializer);
        sse_encode_DartFn_Inputs_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession_Output_unit_AnyhowException(
            onConnect, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 53, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiApiSbSessionSetOnConnectConstMeta,
      argValues: [that, onConnect],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiApiSbSessionSetOnConnectConstMeta =>
      const TaskConstMeta(
        debugName: "SbSession_set_on_connect",
        argNames: ["that", "onConnect"],
      );

  @override
  Future<void> scatterbrainApiMdnsServiceScannerDiscoverDevices(
      {required ServiceScanner that,
      required FutureOr<void> Function(List<HostRecord>) cb}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
            that, serializer);
        sse_encode_DartFn_Inputs_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord_Output_unit_AnyhowException(
            cb, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 54, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kScatterbrainApiMdnsServiceScannerDiscoverDevicesConstMeta,
      argValues: [that, cb],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kScatterbrainApiMdnsServiceScannerDiscoverDevicesConstMeta =>
          const TaskConstMeta(
            debugName: "ServiceScanner_discover_devices",
            argNames: ["that", "cb"],
          );

  @override
  ServiceScanner scatterbrainApiMdnsServiceScannerNew() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 55)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsServiceScannerNewConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsServiceScannerNewConstMeta =>
      const TaskConstMeta(
        debugName: "ServiceScanner_new",
        argNames: [],
      );

  @override
  Future<void> scatterbrainApiMdnsServiceScannerStopScan(
      {required ServiceScanner that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 56, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiMdnsServiceScannerStopScanConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiMdnsServiceScannerStopScanConstMeta =>
      const TaskConstMeta(
        debugName: "ServiceScanner_stop_scan",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiDbConnectionSubrosaDbDeleteGroup(
      {required SubrosaDb that, required UuidValue uuid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(uuid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 57, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbDeleteGroupConstMeta,
      argValues: [that, uuid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbDeleteGroupConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_delete_group",
        argNames: ["that", "uuid"],
      );

  @override
  Future<void> crateApiDbConnectionSubrosaDbDeletePost(
      {required SubrosaDb that, required UuidValue uuid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(uuid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 58, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbDeletePostConstMeta,
      argValues: [that, uuid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbDeletePostConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_delete_post",
        argNames: ["that", "uuid"],
      );

  @override
  Future<List<User>> crateApiDbConnectionSubrosaDbGetAllUsers(
      {required SubrosaDb that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 59, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_user,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetAllUsersConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetAllUsersConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_all_users",
        argNames: ["that"],
      );

  @override
  Future<List<User>> crateApiDbConnectionSubrosaDbGetAllUsersByOwnership(
      {required SubrosaDb that, required bool owned}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_bool(owned, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 60, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_user,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetAllUsersByOwnershipConstMeta,
      argValues: [that, owned],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbConnectionSubrosaDbGetAllUsersByOwnershipConstMeta =>
          const TaskConstMeta(
            debugName: "SubrosaDb_get_all_users_by_ownership",
            argNames: ["that", "owned"],
          );

  @override
  Future<void> crateApiDbConnectionSubrosaDbGetConnection(
      {required SubrosaDb that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 61, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetConnectionConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetConnectionConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_connection",
        argNames: ["that"],
      );

  @override
  Future<NewsGroup?> crateApiDbConnectionSubrosaDbGetGroup(
      {required SubrosaDb that, required UuidValue uuid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(uuid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 62, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetGroupConstMeta,
      argValues: [that, uuid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetGroupConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_group",
        argNames: ["that", "uuid"],
      );

  @override
  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbGetGroupsForParent(
      {required SubrosaDb that, required UuidValue parent}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(parent, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 63, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetGroupsForParentConstMeta,
      argValues: [that, parent],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetGroupsForParentConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_groups_for_parent",
        argNames: ["that", "parent"],
      );

  @override
  Future<CachedIdentity> crateApiDbConnectionSubrosaDbGetIdentity(
      {required SubrosaDb that, required UuidValue uuid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(uuid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 64, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_cached_identity,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetIdentityConstMeta,
      argValues: [that, uuid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetIdentityConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_identity",
        argNames: ["that", "uuid"],
      );

  @override
  Future<DateTime?> crateApiDbConnectionSubrosaDbGetLastSyncDate(
      {required SubrosaDb that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 65, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_Chrono_Naive,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetLastSyncDateConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetLastSyncDateConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_last_sync_date",
        argNames: ["that"],
      );

  @override
  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbGetParents(
      {required SubrosaDb that, required UuidValue group}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(group, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 66, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetParentsConstMeta,
      argValues: [that, group],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetParentsConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_parents",
        argNames: ["that", "group"],
      );

  @override
  Future<List<Posts>> crateApiDbConnectionSubrosaDbGetPosts(
      {required SubrosaDb that, required UuidValue parent}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(parent, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 67, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_posts,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetPostsConstMeta,
      argValues: [that, parent],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetPostsConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_posts",
        argNames: ["that", "parent"],
      );

  @override
  Future<List<PostWithIdentity>>
      crateApiDbConnectionSubrosaDbGetPostsWithIdentity(
          {required SubrosaDb that, required UuidValue parent}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(parent, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 68, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_post_with_identity,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetPostsWithIdentityConstMeta,
      argValues: [that, parent],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbConnectionSubrosaDbGetPostsWithIdentityConstMeta =>
          const TaskConstMeta(
            debugName: "SubrosaDb_get_posts_with_identity",
            argNames: ["that", "parent"],
          );

  @override
  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbGetRootGroups(
      {required SubrosaDb that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 69, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetRootGroupsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetRootGroupsConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_root_groups",
        argNames: ["that"],
      );

  @override
  Future<PlatformInt64> crateApiDbConnectionSubrosaDbGetTotalPosts(
      {required SubrosaDb that, required UuidValue group}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(group, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 70, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_i_64,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetTotalPostsConstMeta,
      argValues: [that, group],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetTotalPostsConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_total_posts",
        argNames: ["that", "group"],
      );

  @override
  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbGetUnsentGroups(
      {required SubrosaDb that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 71, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetUnsentGroupsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetUnsentGroupsConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_unsent_groups",
        argNames: ["that"],
      );

  @override
  Future<List<Posts>> crateApiDbConnectionSubrosaDbGetUnsentPosts(
      {required SubrosaDb that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 72, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_list_posts,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetUnsentPostsConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetUnsentPostsConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_unsent_posts",
        argNames: ["that"],
      );

  @override
  Future<User?> crateApiDbConnectionSubrosaDbGetUser(
      {required SubrosaDb that, required UuidValue identity}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(identity, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 73, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_opt_box_autoadd_user,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetUserConstMeta,
      argValues: [that, identity],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetUserConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_user",
        argNames: ["that", "identity"],
      );

  @override
  Watcher crateApiDbConnectionSubrosaDbGetWatcher({required SubrosaDb that}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 74)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbGetWatcherConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbGetWatcherConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_get_watcher",
        argNames: ["that"],
      );

  @override
  Future<void> crateApiDbConnectionSubrosaDbInsertGroup(
      {required SubrosaDb that, required NewsGroup group}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            group, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 75, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbInsertGroupConstMeta,
      argValues: [that, group],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbInsertGroupConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_insert_group",
        argNames: ["that", "group"],
      );

  @override
  Future<void> crateApiDbConnectionSubrosaDbInsertMessage(
      {required SubrosaDb that, required Message message}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_box_autoadd_message(message, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 76, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbInsertMessageConstMeta,
      argValues: [that, message],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbInsertMessageConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_insert_message",
        argNames: ["that", "message"],
      );

  @override
  Future<void> crateApiDbConnectionSubrosaDbMarkSentGroups(
      {required SubrosaDb that, required List<Value> ids}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
            ids, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 77, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbMarkSentGroupsConstMeta,
      argValues: [that, ids],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbMarkSentGroupsConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_mark_sent_groups",
        argNames: ["that", "ids"],
      );

  @override
  Future<void> crateApiDbConnectionSubrosaDbMarkSentPosts(
      {required SubrosaDb that, required List<Value> ids}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
            ids, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 78, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbMarkSentPostsConstMeta,
      argValues: [that, ids],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbMarkSentPostsConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_mark_sent_posts",
        argNames: ["that", "ids"],
      );

  @override
  SubrosaDb crateApiDbConnectionSubrosaDbNew({required String path}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(path, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 79)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbNewConstMeta,
      argValues: [path],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbNewConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_new",
        argNames: ["path"],
      );

  @override
  SubrosaDb crateApiDbConnectionSubrosaDbNewInMemory() {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 80)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbNewInMemoryConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbNewInMemoryConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_new_in_memory",
        argNames: [],
      );

  @override
  Future<void> crateApiDbConnectionSubrosaDbProcessScatterMessages(
      {required SubrosaDb that, required List<Message> messages}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_list_message(messages, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 81, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbProcessScatterMessagesConstMeta,
      argValues: [that, messages],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbConnectionSubrosaDbProcessScatterMessagesConstMeta =>
          const TaskConstMeta(
            debugName: "SubrosaDb_process_scatter_messages",
            argNames: ["that", "messages"],
          );

  @override
  Future<void> crateApiDbConnectionSubrosaDbSync(
      {required SubrosaDb that, required SbSession sbConnection}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            sbConnection, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 82, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbSyncConstMeta,
      argValues: [that, sbConnection],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbSyncConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_sync",
        argNames: ["that", "sbConnection"],
      );

  @override
  Future<List<NewsGroup>> crateApiDbConnectionSubrosaDbTest(
      {required SubrosaDb that, required UuidValue uuid}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        sse_encode_Uuid(uuid, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 83, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbTestConstMeta,
      argValues: [that, uuid],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbTestConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_test",
        argNames: ["that", "uuid"],
      );

  @override
  Future<NewsGroup?> crateApiDbConnectionSubrosaDbTestNullable(
      {required SubrosaDb that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 84, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbTestNullableConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbTestNullableConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_test_nullable",
        argNames: ["that"],
      );

  @override
  Future<NewsGroup> crateApiDbConnectionSubrosaDbTestOne(
      {required SubrosaDb that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 85, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbConnectionSubrosaDbTestOneConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionSubrosaDbTestOneConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaDb_test_one",
        argNames: ["that"],
      );

  @override
  Future<Message> crateApiProtoSerSubrosaMessageGetMessage(
      {required SubrosaMessage that}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
            that, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 86, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_message,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiProtoSerSubrosaMessageGetMessageConstMeta,
      argValues: [that],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiProtoSerSubrosaMessageGetMessageConstMeta =>
      const TaskConstMeta(
        debugName: "SubrosaMessage_get_message",
        argNames: ["that"],
      );

  @override
  SubrosaMessage crateApiProtoSerSubrosaMessageHandleSubrosaMessage(
      {required Message sbMessage}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_message(sbMessage, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 87)!;
      },
      codec: SseCodec(
        decodeSuccessData:
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiProtoSerSubrosaMessageHandleSubrosaMessageConstMeta,
      argValues: [sbMessage],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiProtoSerSubrosaMessageHandleSubrosaMessageConstMeta =>
          const TaskConstMeta(
            debugName: "SubrosaMessage_handle_subrosa_message",
            argNames: ["sbMessage"],
          );

  @override
  Future<void> crateApiDbConnectionWatcherWatch(
      {required Watcher that,
      required String table,
      required FutureOr<void> Function(SubrosaDb) cb}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
            that, serializer);
        sse_encode_String(table, serializer);
        sse_encode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb_Output_unit_AnyhowException(
            cb, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 127, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbConnectionWatcherWatchConstMeta,
      argValues: [that, table, cb],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbConnectionWatcherWatchConstMeta =>
      const TaskConstMeta(
        debugName: "Watcher_watch",
        argNames: ["that", "table", "cb"],
      );

  @override
  Future<void> crateApiDbEntitiesCachedIdentityDelete(
      {required CachedIdentity that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cached_identity(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 128, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesCachedIdentityDeleteConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesCachedIdentityDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "cached_identity_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbEntitiesCachedIdentityHasParams() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 129, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesCachedIdentityHasParamsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesCachedIdentityHasParamsConstMeta =>
      const TaskConstMeta(
        debugName: "cached_identity_has_params",
        argNames: [],
      );

  @override
  Future<void> crateApiDbEntitiesCachedIdentityInsert(
      {required CachedIdentity that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cached_identity(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 130, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesCachedIdentityInsertConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesCachedIdentityInsertConstMeta =>
      const TaskConstMeta(
        debugName: "cached_identity_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbEntitiesCachedIdentityInsertOnConflict(
      {required CachedIdentity that,
      required SubrosaDb conn,
      required OnConflict onConflict}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cached_identity(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        sse_encode_on_conflict(onConflict, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 131, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesCachedIdentityInsertOnConflictConstMeta,
      argValues: [that, conn, onConflict],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesCachedIdentityInsertOnConflictConstMeta =>
          const TaskConstMeta(
            debugName: "cached_identity_insert_on_conflict",
            argNames: ["that", "conn", "onConflict"],
          );

  @override
  Future<bool> crateApiDbEntitiesCachedIdentityIsEntity() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 132, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesCachedIdentityIsEntityConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesCachedIdentityIsEntityConstMeta =>
      const TaskConstMeta(
        debugName: "cached_identity_is_entity",
        argNames: [],
      );

  @override
  Future<void> crateApiDbEntitiesCachedIdentityUpdate(
      {required CachedIdentity that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_cached_identity(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 133, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesCachedIdentityUpdateConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesCachedIdentityUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "cached_identity_update",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbSyncConnTest({required SbSession session}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            session, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 134, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbSyncConnTestConstMeta,
      argValues: [session],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbSyncConnTestConstMeta => const TaskConstMeta(
        debugName: "conn_test",
        argNames: ["session"],
      );

  @override
  Future<CryptoConfig> scatterbrainApiTypesCryptoConfigGenerate() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 135, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_crypto_config,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiTypesCryptoConfigGenerateConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiTypesCryptoConfigGenerateConstMeta =>
      const TaskConstMeta(
        debugName: "crypto_config_generate",
        argNames: [],
      );

  @override
  Future<void> crateApiInitLogging() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 136, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiInitLoggingConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiInitLoggingConstMeta => const TaskConstMeta(
        debugName: "init_logging",
        argNames: [],
      );

  @override
  Future<Message> scatterbrainApiResponseMessageFromVec(
      {required List<int> body, required String application}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_list_prim_u_8_loose(body, serializer);
        sse_encode_String(application, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 137, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_message,
        decodeErrorData: null,
      ),
      constMeta: kScatterbrainApiResponseMessageFromVecConstMeta,
      argValues: [body, application],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kScatterbrainApiResponseMessageFromVecConstMeta =>
      const TaskConstMeta(
        debugName: "message_from_vec",
        argNames: ["body", "application"],
      );

  @override
  Future<void> crateApiDbEntitiesPostWithIdentityDelete(
      {required PostWithIdentity that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_post_with_identity(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 138, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesPostWithIdentityDeleteConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostWithIdentityDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "post_with_identity_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbEntitiesPostWithIdentityHasParams() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 139, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesPostWithIdentityHasParamsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostWithIdentityHasParamsConstMeta =>
      const TaskConstMeta(
        debugName: "post_with_identity_has_params",
        argNames: [],
      );

  @override
  Future<void> crateApiDbEntitiesPostWithIdentityInsert(
      {required PostWithIdentity that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_post_with_identity(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 140, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesPostWithIdentityInsertConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostWithIdentityInsertConstMeta =>
      const TaskConstMeta(
        debugName: "post_with_identity_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbEntitiesPostWithIdentityInsertOnConflict(
      {required PostWithIdentity that,
      required SubrosaDb conn,
      required OnConflict onConflict}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_post_with_identity(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        sse_encode_on_conflict(onConflict, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 141, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesPostWithIdentityInsertOnConflictConstMeta,
      argValues: [that, conn, onConflict],
      apiImpl: this,
    ));
  }

  TaskConstMeta
      get kCrateApiDbEntitiesPostWithIdentityInsertOnConflictConstMeta =>
          const TaskConstMeta(
            debugName: "post_with_identity_insert_on_conflict",
            argNames: ["that", "conn", "onConflict"],
          );

  @override
  Future<bool> crateApiDbEntitiesPostWithIdentityIsEntity() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 142, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesPostWithIdentityIsEntityConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostWithIdentityIsEntityConstMeta =>
      const TaskConstMeta(
        debugName: "post_with_identity_is_entity",
        argNames: [],
      );

  @override
  Future<void> crateApiDbEntitiesPostWithIdentityUpdate(
      {required PostWithIdentity that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_post_with_identity(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 143, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesPostWithIdentityUpdateConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostWithIdentityUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "post_with_identity_update",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbEntitiesPostsDelete(
      {required Posts that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_posts(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 144, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesPostsDeleteConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostsDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "posts_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbEntitiesPostsHasParams() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 145, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesPostsHasParamsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostsHasParamsConstMeta =>
      const TaskConstMeta(
        debugName: "posts_has_params",
        argNames: [],
      );

  @override
  Future<void> crateApiDbEntitiesPostsInsert(
      {required Posts that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_posts(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 146, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesPostsInsertConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostsInsertConstMeta =>
      const TaskConstMeta(
        debugName: "posts_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbEntitiesPostsInsertOnConflict(
      {required Posts that,
      required SubrosaDb conn,
      required OnConflict onConflict}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_posts(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        sse_encode_on_conflict(onConflict, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 147, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesPostsInsertOnConflictConstMeta,
      argValues: [that, conn, onConflict],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostsInsertOnConflictConstMeta =>
      const TaskConstMeta(
        debugName: "posts_insert_on_conflict",
        argNames: ["that", "conn", "onConflict"],
      );

  @override
  Future<bool> crateApiDbEntitiesPostsIsEntity() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 148, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesPostsIsEntityConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostsIsEntityConstMeta =>
      const TaskConstMeta(
        debugName: "posts_is_entity",
        argNames: [],
      );

  @override
  Posts crateApiDbEntitiesPostsNew(
      {required String header,
      required String body,
      required UuidValue group}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(header, serializer);
        sse_encode_String(body, serializer);
        sse_encode_Uuid(group, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 149)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_posts,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesPostsNewConstMeta,
      argValues: [header, body, group],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostsNewConstMeta => const TaskConstMeta(
        debugName: "posts_new",
        argNames: ["header", "body", "group"],
      );

  @override
  Posts crateApiDbEntitiesPostsNewIdentity(
      {required String header,
      required String body,
      required Identity author,
      required UuidValue group}) {
    return handler.executeSync(SyncTask(
      callFfi: () {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_String(header, serializer);
        sse_encode_String(body, serializer);
        sse_encode_box_autoadd_identity(author, serializer);
        sse_encode_Uuid(group, serializer);
        return pdeCallFfi(generalizedFrbRustBinding, serializer, funcId: 150)!;
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_posts,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesPostsNewIdentityConstMeta,
      argValues: [header, body, author, group],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostsNewIdentityConstMeta =>
      const TaskConstMeta(
        debugName: "posts_new_identity",
        argNames: ["header", "body", "author", "group"],
      );

  @override
  Future<void> crateApiDbEntitiesPostsUpdate(
      {required Posts that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_posts(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 151, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesPostsUpdateConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesPostsUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "posts_update",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbMigrationsRunMigrations({required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 152, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbMigrationsRunMigrationsConstMeta,
      argValues: [conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbMigrationsRunMigrationsConstMeta =>
      const TaskConstMeta(
        debugName: "run_migrations",
        argNames: ["conn"],
      );

  @override
  Future<void> crateApiDbEntitiesUserDelete(
      {required User that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_user(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 153, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesUserDeleteConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesUserDeleteConstMeta =>
      const TaskConstMeta(
        debugName: "user_delete",
        argNames: ["that", "conn"],
      );

  @override
  Future<bool> crateApiDbEntitiesUserHasParams() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 154, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesUserHasParamsConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesUserHasParamsConstMeta =>
      const TaskConstMeta(
        debugName: "user_has_params",
        argNames: [],
      );

  @override
  Future<void> crateApiDbEntitiesUserInsert(
      {required User that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_user(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 155, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesUserInsertConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesUserInsertConstMeta =>
      const TaskConstMeta(
        debugName: "user_insert",
        argNames: ["that", "conn"],
      );

  @override
  Future<void> crateApiDbEntitiesUserInsertOnConflict(
      {required User that,
      required SubrosaDb conn,
      required OnConflict onConflict}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_user(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        sse_encode_on_conflict(onConflict, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 156, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesUserInsertOnConflictConstMeta,
      argValues: [that, conn, onConflict],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesUserInsertOnConflictConstMeta =>
      const TaskConstMeta(
        debugName: "user_insert_on_conflict",
        argNames: ["that", "conn", "onConflict"],
      );

  @override
  Future<bool> crateApiDbEntitiesUserIsEntity() {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 157, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_bool,
        decodeErrorData: null,
      ),
      constMeta: kCrateApiDbEntitiesUserIsEntityConstMeta,
      argValues: [],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesUserIsEntityConstMeta =>
      const TaskConstMeta(
        debugName: "user_is_entity",
        argNames: [],
      );

  @override
  Future<void> crateApiDbEntitiesUserUpdate(
      {required User that, required SubrosaDb conn}) {
    return handler.executeNormal(NormalTask(
      callFfi: (port_) {
        final serializer = SseSerializer(generalizedFrbRustBinding);
        sse_encode_box_autoadd_user(that, serializer);
        sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
            conn, serializer);
        pdeCallFfi(generalizedFrbRustBinding, serializer,
            funcId: 158, port: port_);
      },
      codec: SseCodec(
        decodeSuccessData: sse_decode_unit,
        decodeErrorData: sse_decode_AnyhowException,
      ),
      constMeta: kCrateApiDbEntitiesUserUpdateConstMeta,
      argValues: [that, conn],
      apiImpl: this,
    ));
  }

  TaskConstMeta get kCrateApiDbEntitiesUserUpdateConstMeta =>
      const TaskConstMeta(
        debugName: "user_update",
        argNames: ["that", "conn"],
      );

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb_Output_unit_AnyhowException(
          FutureOr<void> Function(SubrosaDb) raw) {
    return (callId, rawArg0) async {
      final arg0 =
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
              rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord_Output_unit_AnyhowException(
          FutureOr<void> Function(List<HostRecord>) raw) {
    return (callId, rawArg0) async {
      final arg0 =
          dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
              rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_list_String_Output_bool_AnyhowException(
          FutureOr<bool> Function(List<String>) raw) {
    return (callId, rawArg0) async {
      final arg0 = dco_decode_list_String(rawArg0);

      Box<bool>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_bool(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  Future<void> Function(int, dynamic)
      encode_DartFn_Inputs_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession_Output_unit_AnyhowException(
          FutureOr<void> Function(SbSession?) raw) {
    return (callId, rawArg0) async {
      final arg0 =
          dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
              rawArg0);

      Box<void>? rawOutput;
      Box<AnyhowException>? rawError;
      try {
        rawOutput = Box(await raw(arg0));
      } catch (e, s) {
        rawError = Box(AnyhowException("$e\n\n$s"));
      }

      final serializer = SseSerializer(generalizedFrbRustBinding);
      assert((rawOutput != null) ^ (rawError != null));
      if (rawOutput != null) {
        serializer.buffer.putUint8(0);
        sse_encode_unit(rawOutput.value, serializer);
      } else {
        serializer.buffer.putUint8(1);
        sse_encode_AnyhowException(rawError!.value, serializer);
      }
      final output = serializer.intoRaw();

      generalizedFrbRustBinding.dartFnDeliverOutput(
          callId: callId,
          ptr: output.ptr,
          rustVecLen: output.rustVecLen,
          dataLen: output.dataLen);
    };
  }

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_DartSyncFutureSbResultSbSession => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSyncFuturestaticSbResultSbSession;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_DartSyncFutureSbResultSbSession => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSyncFuturestaticSbResultSbSession;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_HostRecord => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_HostRecord => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Ipv4Addr => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Ipv4Addr => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Ipv6Addr => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Ipv6Addr => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_MessageType => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageType;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_MessageType => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageType;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_NewsGroup => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_NewsGroup => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_PairingSession => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_PairingSession => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Parent => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Parent => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ProtoUuid => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtoUuid;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ProtoUuid => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtoUuid;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SbEvent => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SbEvent => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SbResult => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResult;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SbResult => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResult;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SbResultString => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResultString;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SbResultString => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResultString;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SbSession => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SbSession => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_ServiceScanner => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_ServiceScanner => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubrosaDb => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubrosaDb => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_SubrosaMessage => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_SubrosaMessage => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_TryPairConfirm => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryPairConfirm;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_TryPairConfirm => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryPairConfirm;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_TypePrefix => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTypePrefix;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_TypePrefix => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTypePrefix;

  RustArcIncrementStrongCountFnType get rust_arc_increment_strong_count_Value =>
      wire.rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue;

  RustArcDecrementStrongCountFnType get rust_arc_decrement_strong_count_Value =>
      wire.rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue;

  RustArcIncrementStrongCountFnType
      get rust_arc_increment_strong_count_Watcher => wire
          .rust_arc_increment_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher;

  RustArcDecrementStrongCountFnType
      get rust_arc_decrement_strong_count_Watcher => wire
          .rust_arc_decrement_strong_count_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher;

  @protected
  AnyhowException dco_decode_AnyhowException(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return AnyhowException(raw as String);
  }

  @protected
  DartSyncFutureSbResultSbSession
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSyncFuturestaticSbResultSbSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DartSyncFutureSbResultSbSessionImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  HostRecord
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HostRecordImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ipv4Addr
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ipv4AddrImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ipv6Addr
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ipv6AddrImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MessageType
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageType(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MessageTypeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NewsGroup
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NewsGroupImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PairingSession
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PairingSessionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Parent
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ParentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtoUuid
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtoUuid(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtoUuidImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbEvent
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbEventImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbResult
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResult(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbResultImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbResultString
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResultString(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbResultStringImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbSession
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbSessionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ServiceScanner
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ServiceScannerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubrosaDb
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubrosaDbImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubrosaMessage
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubrosaMessageImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TryPairConfirm
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryPairConfirm(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TryPairConfirmImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TypePrefix
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTypePrefix(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TypePrefixImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Value
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ValueImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Watcher
      dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WatcherImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NewsGroup
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NewsGroupImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PairingSession
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PairingSessionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ServiceScanner
      dco_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ServiceScannerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  HostRecord
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HostRecordImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ipv4Addr
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ipv4AddrImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ipv6Addr
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ipv6AddrImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NewsGroup
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NewsGroupImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PairingSession
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PairingSessionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbSession
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbSessionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubrosaDb
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubrosaDbImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubrosaMessage
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubrosaMessageImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Watcher
      dco_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WatcherImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  DateTime dco_decode_Chrono_Naive(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeTimestamp(ts: dco_decode_i_64(raw).toInt(), isUtc: true);
  }

  @protected
  FutureOr<void> Function(SubrosaDb)
      dco_decode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(List<HostRecord>)
      dco_decode_DartFn_Inputs_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<bool> Function(List<String>)
      dco_decode_DartFn_Inputs_list_String_Output_bool_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  FutureOr<void> Function(SbSession?)
      dco_decode_DartFn_Inputs_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession_Output_unit_AnyhowException(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError('');
  }

  @protected
  Object dco_decode_DartOpaque(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return decodeDartOpaque(raw, generalizedFrbRustBinding);
  }

  @protected
  Map<String, Uint8List> dco_decode_Map_String_list_prim_u_8_strict(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Map.fromEntries(
        dco_decode_list_record_string_list_prim_u_8_strict(raw)
            .map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  DartSyncFutureSbResultSbSession
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSyncFuturestaticSbResultSbSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return DartSyncFutureSbResultSbSessionImpl.frbInternalDcoDecode(
        raw as List<dynamic>);
  }

  @protected
  HostRecord
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return HostRecordImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ipv4Addr
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ipv4AddrImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Ipv6Addr
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return Ipv6AddrImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  MessageType
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageType(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return MessageTypeImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  NewsGroup
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return NewsGroupImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  PairingSession
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return PairingSessionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Parent
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ParentImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ProtoUuid
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtoUuid(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ProtoUuidImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbEvent
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbEventImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbResult
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResult(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbResultImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbResultString
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResultString(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbResultStringImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SbSession
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SbSessionImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  ServiceScanner
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ServiceScannerImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubrosaDb
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubrosaDbImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  SubrosaMessage
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return SubrosaMessageImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TryPairConfirm
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryPairConfirm(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TryPairConfirmImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  TypePrefix
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTypePrefix(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return TypePrefixImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Value
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return ValueImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  Watcher
      dco_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return WatcherImpl.frbInternalDcoDecode(raw as List<dynamic>);
  }

  @protected
  String dco_decode_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as String;
  }

  @protected
  Crud dco_decode_TraitDef_Crud(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  Dao dco_decode_TraitDef_Dao(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  FromRow dco_decode_TraitDef_FromRow(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  GetParams dco_decode_TraitDef_GetParams(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  GetType dco_decode_TraitDef_GetType(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  IntoRemoteErr dco_decode_TraitDef_IntoRemoteErr(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  PrettyPrint dco_decode_TraitDef_PrettyPrint(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  ProtoStreamTrait dco_decode_TraitDef_ProtoStreamTrait(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  Sender dco_decode_TraitDef_Sender(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  ServiceScannerLike dco_decode_TraitDef_ServiceScannerLike(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  SubrosaDao dco_decode_TraitDef_SubrosaDao(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  TestDao dco_decode_TraitDef_TestDao(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  ToUuid dco_decode_TraitDef_ToUuid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    throw UnimplementedError();
  }

  @protected
  UuidValue dco_decode_Uuid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return UuidValue.fromByteList(dco_decode_list_prim_u_8_strict(raw));
  }

  @protected
  bool dco_decode_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  NewsGroup
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
        raw);
  }

  @protected
  Parent
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
        raw);
  }

  @protected
  SbSession
      dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
        raw);
  }

  @protected
  DateTime dco_decode_box_autoadd_Chrono_Naive(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_Chrono_Naive(raw);
  }

  @protected
  bool dco_decode_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as bool;
  }

  @protected
  CachedIdentity dco_decode_box_autoadd_cached_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_cached_identity(raw);
  }

  @protected
  CryptoConfig dco_decode_box_autoadd_crypto_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_crypto_config(raw);
  }

  @protected
  int dco_decode_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  Identity dco_decode_box_autoadd_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_identity(raw);
  }

  @protected
  Message dco_decode_box_autoadd_message(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_message(raw);
  }

  @protected
  PostWithIdentity dco_decode_box_autoadd_post_with_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_post_with_identity(raw);
  }

  @protected
  Posts dco_decode_box_autoadd_posts(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_posts(raw);
  }

  @protected
  int dco_decode_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  User dco_decode_box_autoadd_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dco_decode_user(raw);
  }

  @protected
  CachedIdentity dco_decode_cached_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return CachedIdentity(
      uuid: dco_decode_Uuid(arr[0]),
      fingerprint: dco_decode_opt_Uuid(arr[1]),
      userName: dco_decode_opt_String(arr[2]),
      bio: dco_decode_opt_String(arr[3]),
      owned: dco_decode_opt_box_autoadd_bool(arr[4]),
      imageBytes: dco_decode_opt_list_prim_u_8_strict(arr[5]),
    );
  }

  @protected
  CryptoConfig dco_decode_crypto_config(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 3)
      throw Exception('unexpected arr length: expect 3 but see ${arr.length}');
    return CryptoConfig(
      secretkey: dco_decode_String(arr[0]),
      pubkey: dco_decode_String(arr[1]),
      remotekey: dco_decode_opt_String(arr[2]),
    );
  }

  @protected
  int dco_decode_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  PlatformInt64 dco_decode_i_64(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  Identity dco_decode_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 6)
      throw Exception('unexpected arr length: expect 6 but see ${arr.length}');
    return Identity(
      fingerprint: dco_decode_opt_Uuid(arr[0]),
      name: dco_decode_String(arr[1]),
      publicKey: dco_decode_list_prim_u_8_strict(arr[2]),
      isOwned: dco_decode_bool(arr[3]),
      extra: dco_decode_Map_String_list_prim_u_8_strict(arr[4]),
      sig: dco_decode_list_prim_u_8_strict(arr[5]),
    );
  }

  @protected
  ImportIdentityState dco_decode_import_identity_state(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return ImportIdentityState_Initiated(
          dco_decode_Uuid(raw[1]),
        );
      case 1:
        return ImportIdentityState_Complete(
          dco_decode_Uuid(raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  IpAddr dco_decode_ip_addr(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return IpAddr_V4(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
              raw[1]),
        );
      case 1:
        return IpAddr_V6(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
              raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PlatformInt64 dco_decode_isize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeI64(raw);
  }

  @protected
  List<HostRecord>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord)
        .toList();
  }

  @protected
  List<NewsGroup>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup)
        .toList();
  }

  @protected
  List<SbEvent>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent)
        .toList();
  }

  @protected
  List<Value>
      dco_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(
            dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue)
        .toList();
  }

  @protected
  List<String> dco_decode_list_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_String).toList();
  }

  @protected
  List<Identity> dco_decode_list_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_identity).toList();
  }

  @protected
  List<IpAddr> dco_decode_list_ip_addr(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_ip_addr).toList();
  }

  @protected
  List<Message> dco_decode_list_message(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_message).toList();
  }

  @protected
  List<PostWithIdentity> dco_decode_list_post_with_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_post_with_identity).toList();
  }

  @protected
  List<Posts> dco_decode_list_posts(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_posts).toList();
  }

  @protected
  List<int> dco_decode_list_prim_u_8_loose(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as List<int>;
  }

  @protected
  Uint8List dco_decode_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as Uint8List;
  }

  @protected
  List<(String, Uint8List)> dco_decode_list_record_string_list_prim_u_8_strict(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>)
        .map(dco_decode_record_string_list_prim_u_8_strict)
        .toList();
  }

  @protected
  List<User> dco_decode_list_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return (raw as List<dynamic>).map(dco_decode_user).toList();
  }

  @protected
  Message dco_decode_message(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 11)
      throw Exception('unexpected arr length: expect 11 but see ${arr.length}');
    return Message(
      fromFingerprint: dco_decode_opt_Uuid(arr[0]),
      toFingerprint: dco_decode_opt_Uuid(arr[1]),
      application: dco_decode_String(arr[2]),
      extension_: dco_decode_String(arr[3]),
      mime: dco_decode_String(arr[4]),
      sendDate: dco_decode_i_64(arr[5]),
      receiveDate: dco_decode_i_64(arr[6]),
      isFile: dco_decode_bool(arr[7]),
      id: dco_decode_opt_Uuid(arr[8]),
      body: dco_decode_list_prim_u_8_strict(arr[9]),
      fileName: dco_decode_String(arr[10]),
    );
  }

  @protected
  OnConflict dco_decode_on_conflict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return OnConflict.values[raw as int];
  }

  @protected
  String? dco_decode_opt_String(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_String(raw);
  }

  @protected
  UuidValue? dco_decode_opt_Uuid(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_Uuid(raw);
  }

  @protected
  NewsGroup?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
            raw);
  }

  @protected
  Parent?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
            raw);
  }

  @protected
  SbSession?
      dco_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null
        ? null
        : dco_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            raw);
  }

  @protected
  DateTime? dco_decode_opt_box_autoadd_Chrono_Naive(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_Chrono_Naive(raw);
  }

  @protected
  bool? dco_decode_opt_box_autoadd_bool(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_bool(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_i_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_i_32(raw);
  }

  @protected
  int? dco_decode_opt_box_autoadd_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_u_32(raw);
  }

  @protected
  User? dco_decode_opt_box_autoadd_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_box_autoadd_user(raw);
  }

  @protected
  Uint8List? dco_decode_opt_list_prim_u_8_strict(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw == null ? null : dco_decode_list_prim_u_8_strict(raw);
  }

  @protected
  PairResult dco_decode_pair_result(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2)
      throw Exception('unexpected arr length: expect 2 but see ${arr.length}');
    return PairResult(
      remotekey: dco_decode_String(arr[0]),
      session:
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
              arr[1]),
    );
  }

  @protected
  PairStatus dco_decode_pair_status(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    switch (raw[0]) {
      case 0:
        return PairStatus_Paired(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
              raw[1]),
        );
      case 1:
        return PairStatus_NotPaired(
          dco_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
              raw[1]),
        );
      default:
        throw Exception("unreachable");
    }
  }

  @protected
  PostWithIdentity dco_decode_post_with_identity(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 14)
      throw Exception('unexpected arr length: expect 14 but see ${arr.length}');
    return PostWithIdentity(
      author: dco_decode_opt_String(arr[0]),
      header: dco_decode_opt_String(arr[1]),
      body: dco_decode_opt_String(arr[2]),
      sig: dco_decode_opt_list_prim_u_8_strict(arr[3]),
      receiveDate: dco_decode_Chrono_Naive(arr[4]),
      postId: dco_decode_Uuid(arr[5]),
      identity: dco_decode_opt_Uuid(arr[6]),
      parentGroup: dco_decode_Uuid(arr[7]),
      sent: dco_decode_bool(arr[8]),
      fingerprint: dco_decode_opt_Uuid(arr[9]),
      userName: dco_decode_opt_String(arr[10]),
      bio: dco_decode_opt_String(arr[11]),
      owned: dco_decode_opt_box_autoadd_bool(arr[12]),
      imageBytes: dco_decode_opt_list_prim_u_8_strict(arr[13]),
    );
  }

  @protected
  Posts dco_decode_posts(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 8)
      throw Exception('unexpected arr length: expect 8 but see ${arr.length}');
    return Posts.raw(
      header: dco_decode_opt_String(arr[0]),
      body: dco_decode_opt_String(arr[1]),
      sig: dco_decode_opt_list_prim_u_8_strict(arr[2]),
      receiveDate: dco_decode_Chrono_Naive(arr[3]),
      postId: dco_decode_Uuid(arr[4]),
      identity: dco_decode_opt_Uuid(arr[5]),
      parentGroup: dco_decode_Uuid(arr[6]),
      sent: dco_decode_bool(arr[7]),
    );
  }

  @protected
  (String, Uint8List) dco_decode_record_string_list_prim_u_8_strict(
      dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 2) {
      throw Exception('Expected 2 elements, got ${arr.length}');
    }
    return (
      dco_decode_String(arr[0]),
      dco_decode_list_prim_u_8_strict(arr[1]),
    );
  }

  @protected
  int dco_decode_u_16(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_32(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  int dco_decode_u_8(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return raw as int;
  }

  @protected
  void dco_decode_unit(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return;
  }

  @protected
  User dco_decode_user(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    final arr = raw as List<dynamic>;
    if (arr.length != 5)
      throw Exception('unexpected arr length: expect 5 but see ${arr.length}');
    return User(
      identity: dco_decode_Uuid(arr[0]),
      userName: dco_decode_String(arr[1]),
      bio: dco_decode_String(arr[2]),
      owned: dco_decode_bool(arr[3]),
      imageBytes: dco_decode_list_prim_u_8_strict(arr[4]),
    );
  }

  @protected
  BigInt dco_decode_usize(dynamic raw) {
    // Codec=Dco (DartCObject based), see doc to use other codecs
    return dcoDecodeU64(raw);
  }

  @protected
  AnyhowException sse_decode_AnyhowException(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_String(deserializer);
    return AnyhowException(inner);
  }

  @protected
  DartSyncFutureSbResultSbSession
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSyncFuturestaticSbResultSbSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DartSyncFutureSbResultSbSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  HostRecord
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return HostRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ipv4Addr
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ipv4AddrImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ipv6Addr
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ipv6AddrImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MessageType
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageType(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MessageTypeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NewsGroup
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NewsGroupImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PairingSession
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PairingSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Parent
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ParentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtoUuid
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtoUuid(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtoUuidImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbEvent
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbEventImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbResult
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResult(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbResultImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbResultString
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResultString(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbResultStringImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbSession
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ServiceScanner
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ServiceScannerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubrosaDb
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubrosaDbImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubrosaMessage
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubrosaMessageImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  TryPairConfirm
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryPairConfirm(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TryPairConfirmImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  TypePrefix
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTypePrefix(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TypePrefixImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Value
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ValueImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Watcher
      sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WatcherImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NewsGroup
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NewsGroupImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PairingSession
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PairingSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ServiceScanner
      sse_decode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ServiceScannerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  HostRecord
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return HostRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ipv4Addr
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ipv4AddrImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ipv6Addr
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ipv6AddrImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NewsGroup
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NewsGroupImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PairingSession
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PairingSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbSession
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubrosaDb
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubrosaDbImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubrosaMessage
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubrosaMessageImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Watcher
      sse_decode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WatcherImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  DateTime sse_decode_Chrono_Naive(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_64(deserializer);
    return DateTime.fromMicrosecondsSinceEpoch(inner.toInt(), isUtc: true);
  }

  @protected
  Object sse_decode_DartOpaque(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_isize(deserializer);
    return decodeDartOpaque(inner, generalizedFrbRustBinding);
  }

  @protected
  Map<String, Uint8List> sse_decode_Map_String_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner =
        sse_decode_list_record_string_list_prim_u_8_strict(deserializer);
    return Map.fromEntries(inner.map((e) => MapEntry(e.$1, e.$2)));
  }

  @protected
  DartSyncFutureSbResultSbSession
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSyncFuturestaticSbResultSbSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return DartSyncFutureSbResultSbSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  HostRecord
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return HostRecordImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ipv4Addr
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ipv4AddrImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Ipv6Addr
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return Ipv6AddrImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  MessageType
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageType(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return MessageTypeImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  NewsGroup
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return NewsGroupImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  PairingSession
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return PairingSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Parent
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ParentImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ProtoUuid
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtoUuid(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ProtoUuidImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbEvent
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbEventImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbResult
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResult(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbResultImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbResultString
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResultString(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbResultStringImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SbSession
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SbSessionImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  ServiceScanner
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ServiceScannerImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubrosaDb
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubrosaDbImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  SubrosaMessage
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return SubrosaMessageImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  TryPairConfirm
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryPairConfirm(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TryPairConfirmImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  TypePrefix
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTypePrefix(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return TypePrefixImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Value
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return ValueImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  Watcher
      sse_decode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return WatcherImpl.frbInternalSseDecode(
        sse_decode_usize(deserializer), sse_decode_i_32(deserializer));
  }

  @protected
  String sse_decode_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return utf8.decoder.convert(inner);
  }

  @protected
  UuidValue sse_decode_Uuid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_list_prim_u_8_strict(deserializer);
    return UuidValue.fromByteList(inner);
  }

  @protected
  bool sse_decode_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8() != 0;
  }

  @protected
  NewsGroup
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
        deserializer));
  }

  @protected
  Parent
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
        deserializer));
  }

  @protected
  SbSession
      sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
        deserializer));
  }

  @protected
  DateTime sse_decode_box_autoadd_Chrono_Naive(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_Chrono_Naive(deserializer));
  }

  @protected
  bool sse_decode_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_bool(deserializer));
  }

  @protected
  CachedIdentity sse_decode_box_autoadd_cached_identity(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_cached_identity(deserializer));
  }

  @protected
  CryptoConfig sse_decode_box_autoadd_crypto_config(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_crypto_config(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_i_32(deserializer));
  }

  @protected
  Identity sse_decode_box_autoadd_identity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_identity(deserializer));
  }

  @protected
  Message sse_decode_box_autoadd_message(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_message(deserializer));
  }

  @protected
  PostWithIdentity sse_decode_box_autoadd_post_with_identity(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_post_with_identity(deserializer));
  }

  @protected
  Posts sse_decode_box_autoadd_posts(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_posts(deserializer));
  }

  @protected
  int sse_decode_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_u_32(deserializer));
  }

  @protected
  User sse_decode_box_autoadd_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return (sse_decode_user(deserializer));
  }

  @protected
  CachedIdentity sse_decode_cached_identity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_uuid = sse_decode_Uuid(deserializer);
    var var_fingerprint = sse_decode_opt_Uuid(deserializer);
    var var_userName = sse_decode_opt_String(deserializer);
    var var_bio = sse_decode_opt_String(deserializer);
    var var_owned = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_imageBytes = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return CachedIdentity(
        uuid: var_uuid,
        fingerprint: var_fingerprint,
        userName: var_userName,
        bio: var_bio,
        owned: var_owned,
        imageBytes: var_imageBytes);
  }

  @protected
  CryptoConfig sse_decode_crypto_config(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_secretkey = sse_decode_String(deserializer);
    var var_pubkey = sse_decode_String(deserializer);
    var var_remotekey = sse_decode_opt_String(deserializer);
    return CryptoConfig(
        secretkey: var_secretkey, pubkey: var_pubkey, remotekey: var_remotekey);
  }

  @protected
  int sse_decode_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getInt32();
  }

  @protected
  PlatformInt64 sse_decode_i_64(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  Identity sse_decode_identity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fingerprint = sse_decode_opt_Uuid(deserializer);
    var var_name = sse_decode_String(deserializer);
    var var_publicKey = sse_decode_list_prim_u_8_strict(deserializer);
    var var_isOwned = sse_decode_bool(deserializer);
    var var_extra = sse_decode_Map_String_list_prim_u_8_strict(deserializer);
    var var_sig = sse_decode_list_prim_u_8_strict(deserializer);
    return Identity(
        fingerprint: var_fingerprint,
        name: var_name,
        publicKey: var_publicKey,
        isOwned: var_isOwned,
        extra: var_extra,
        sig: var_sig);
  }

  @protected
  ImportIdentityState sse_decode_import_identity_state(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 = sse_decode_Uuid(deserializer);
        return ImportIdentityState_Initiated(var_field0);
      case 1:
        var var_field0 = sse_decode_Uuid(deserializer);
        return ImportIdentityState_Complete(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  IpAddr sse_decode_ip_addr(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
                deserializer);
        return IpAddr_V4(var_field0);
      case 1:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
                deserializer);
        return IpAddr_V6(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PlatformInt64 sse_decode_isize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getPlatformInt64();
  }

  @protected
  List<HostRecord>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <HostRecord>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<NewsGroup>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <NewsGroup>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<SbEvent>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <SbEvent>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<Value>
      sse_decode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Value>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(
          sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
              deserializer));
    }
    return ans_;
  }

  @protected
  List<String> sse_decode_list_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <String>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_String(deserializer));
    }
    return ans_;
  }

  @protected
  List<Identity> sse_decode_list_identity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Identity>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_identity(deserializer));
    }
    return ans_;
  }

  @protected
  List<IpAddr> sse_decode_list_ip_addr(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <IpAddr>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_ip_addr(deserializer));
    }
    return ans_;
  }

  @protected
  List<Message> sse_decode_list_message(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Message>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_message(deserializer));
    }
    return ans_;
  }

  @protected
  List<PostWithIdentity> sse_decode_list_post_with_identity(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <PostWithIdentity>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_post_with_identity(deserializer));
    }
    return ans_;
  }

  @protected
  List<Posts> sse_decode_list_posts(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <Posts>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_posts(deserializer));
    }
    return ans_;
  }

  @protected
  List<int> sse_decode_list_prim_u_8_loose(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  Uint8List sse_decode_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var len_ = sse_decode_i_32(deserializer);
    return deserializer.buffer.getUint8List(len_);
  }

  @protected
  List<(String, Uint8List)> sse_decode_list_record_string_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <(String, Uint8List)>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_record_string_list_prim_u_8_strict(deserializer));
    }
    return ans_;
  }

  @protected
  List<User> sse_decode_list_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var len_ = sse_decode_i_32(deserializer);
    var ans_ = <User>[];
    for (var idx_ = 0; idx_ < len_; ++idx_) {
      ans_.add(sse_decode_user(deserializer));
    }
    return ans_;
  }

  @protected
  Message sse_decode_message(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_fromFingerprint = sse_decode_opt_Uuid(deserializer);
    var var_toFingerprint = sse_decode_opt_Uuid(deserializer);
    var var_application = sse_decode_String(deserializer);
    var var_extension_ = sse_decode_String(deserializer);
    var var_mime = sse_decode_String(deserializer);
    var var_sendDate = sse_decode_i_64(deserializer);
    var var_receiveDate = sse_decode_i_64(deserializer);
    var var_isFile = sse_decode_bool(deserializer);
    var var_id = sse_decode_opt_Uuid(deserializer);
    var var_body = sse_decode_list_prim_u_8_strict(deserializer);
    var var_fileName = sse_decode_String(deserializer);
    return Message(
        fromFingerprint: var_fromFingerprint,
        toFingerprint: var_toFingerprint,
        application: var_application,
        extension_: var_extension_,
        mime: var_mime,
        sendDate: var_sendDate,
        receiveDate: var_receiveDate,
        isFile: var_isFile,
        id: var_id,
        body: var_body,
        fileName: var_fileName);
  }

  @protected
  OnConflict sse_decode_on_conflict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var inner = sse_decode_i_32(deserializer);
    return OnConflict.values[inner];
  }

  @protected
  String? sse_decode_opt_String(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_String(deserializer));
    } else {
      return null;
    }
  }

  @protected
  UuidValue? sse_decode_opt_Uuid(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_Uuid(deserializer));
    } else {
      return null;
    }
  }

  @protected
  NewsGroup?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  Parent?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  SbSession?
      sse_decode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          deserializer));
    } else {
      return null;
    }
  }

  @protected
  DateTime? sse_decode_opt_box_autoadd_Chrono_Naive(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_Chrono_Naive(deserializer));
    } else {
      return null;
    }
  }

  @protected
  bool? sse_decode_opt_box_autoadd_bool(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_bool(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_i_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_i_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  int? sse_decode_opt_box_autoadd_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_u_32(deserializer));
    } else {
      return null;
    }
  }

  @protected
  User? sse_decode_opt_box_autoadd_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_box_autoadd_user(deserializer));
    } else {
      return null;
    }
  }

  @protected
  Uint8List? sse_decode_opt_list_prim_u_8_strict(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    if (sse_decode_bool(deserializer)) {
      return (sse_decode_list_prim_u_8_strict(deserializer));
    } else {
      return null;
    }
  }

  @protected
  PairResult sse_decode_pair_result(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_remotekey = sse_decode_String(deserializer);
    var var_session =
        sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            deserializer);
    return PairResult(remotekey: var_remotekey, session: var_session);
  }

  @protected
  PairStatus sse_decode_pair_status(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    var tag_ = sse_decode_i_32(deserializer);
    switch (tag_) {
      case 0:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
                deserializer);
        return PairStatus_Paired(var_field0);
      case 1:
        var var_field0 =
            sse_decode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
                deserializer);
        return PairStatus_NotPaired(var_field0);
      default:
        throw UnimplementedError('');
    }
  }

  @protected
  PostWithIdentity sse_decode_post_with_identity(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_author = sse_decode_opt_String(deserializer);
    var var_header = sse_decode_opt_String(deserializer);
    var var_body = sse_decode_opt_String(deserializer);
    var var_sig = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_receiveDate = sse_decode_Chrono_Naive(deserializer);
    var var_postId = sse_decode_Uuid(deserializer);
    var var_identity = sse_decode_opt_Uuid(deserializer);
    var var_parentGroup = sse_decode_Uuid(deserializer);
    var var_sent = sse_decode_bool(deserializer);
    var var_fingerprint = sse_decode_opt_Uuid(deserializer);
    var var_userName = sse_decode_opt_String(deserializer);
    var var_bio = sse_decode_opt_String(deserializer);
    var var_owned = sse_decode_opt_box_autoadd_bool(deserializer);
    var var_imageBytes = sse_decode_opt_list_prim_u_8_strict(deserializer);
    return PostWithIdentity(
        author: var_author,
        header: var_header,
        body: var_body,
        sig: var_sig,
        receiveDate: var_receiveDate,
        postId: var_postId,
        identity: var_identity,
        parentGroup: var_parentGroup,
        sent: var_sent,
        fingerprint: var_fingerprint,
        userName: var_userName,
        bio: var_bio,
        owned: var_owned,
        imageBytes: var_imageBytes);
  }

  @protected
  Posts sse_decode_posts(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_header = sse_decode_opt_String(deserializer);
    var var_body = sse_decode_opt_String(deserializer);
    var var_sig = sse_decode_opt_list_prim_u_8_strict(deserializer);
    var var_receiveDate = sse_decode_Chrono_Naive(deserializer);
    var var_postId = sse_decode_Uuid(deserializer);
    var var_identity = sse_decode_opt_Uuid(deserializer);
    var var_parentGroup = sse_decode_Uuid(deserializer);
    var var_sent = sse_decode_bool(deserializer);
    return Posts.raw(
        header: var_header,
        body: var_body,
        sig: var_sig,
        receiveDate: var_receiveDate,
        postId: var_postId,
        identity: var_identity,
        parentGroup: var_parentGroup,
        sent: var_sent);
  }

  @protected
  (String, Uint8List) sse_decode_record_string_list_prim_u_8_strict(
      SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_field0 = sse_decode_String(deserializer);
    var var_field1 = sse_decode_list_prim_u_8_strict(deserializer);
    return (var_field0, var_field1);
  }

  @protected
  int sse_decode_u_16(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint16();
  }

  @protected
  int sse_decode_u_32(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint32();
  }

  @protected
  int sse_decode_u_8(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getUint8();
  }

  @protected
  void sse_decode_unit(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  User sse_decode_user(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    var var_identity = sse_decode_Uuid(deserializer);
    var var_userName = sse_decode_String(deserializer);
    var var_bio = sse_decode_String(deserializer);
    var var_owned = sse_decode_bool(deserializer);
    var var_imageBytes = sse_decode_list_prim_u_8_strict(deserializer);
    return User(
        identity: var_identity,
        userName: var_userName,
        bio: var_bio,
        owned: var_owned,
        imageBytes: var_imageBytes);
  }

  @protected
  BigInt sse_decode_usize(SseDeserializer deserializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    return deserializer.buffer.getBigUint64();
  }

  @protected
  void sse_encode_AnyhowException(
      AnyhowException self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.message, serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSyncFuturestaticSbResultSbSession(
          DartSyncFutureSbResultSbSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DartSyncFutureSbResultSbSessionImpl)
            .frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          HostRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as HostRecordImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          Ipv4Addr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Ipv4AddrImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          Ipv6Addr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Ipv6AddrImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageType(
          MessageType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MessageTypeImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          NewsGroup self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NewsGroupImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          PairingSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PairingSessionImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          Parent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ParentImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtoUuid(
          ProtoUuid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProtoUuidImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          SbEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbEventImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResult(
          SbResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbResultImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResultString(
          SbResultString self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbResultStringImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SbSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbSessionImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          ServiceScanner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ServiceScannerImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          SubrosaDb self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubrosaDbImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          SubrosaMessage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubrosaMessageImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryPairConfirm(
          TryPairConfirm self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as TryPairConfirmImpl).frbInternalSseEncode(move: true),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTypePrefix(
          TypePrefix self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as TypePrefixImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          Value self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ValueImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          Watcher self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as WatcherImpl).frbInternalSseEncode(move: true), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          NewsGroup self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NewsGroupImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          PairingSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PairingSessionImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_RefMut_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          ServiceScanner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ServiceScannerImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          HostRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as HostRecordImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          Ipv4Addr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Ipv4AddrImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          Ipv6Addr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Ipv6AddrImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          NewsGroup self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NewsGroupImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          PairingSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PairingSessionImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SbSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbSessionImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          SubrosaDb self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubrosaDbImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          SubrosaMessage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubrosaMessageImpl).frbInternalSseEncode(move: false),
        serializer);
  }

  @protected
  void
      sse_encode_Auto_Ref_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          Watcher self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as WatcherImpl).frbInternalSseEncode(move: false), serializer);
  }

  @protected
  void sse_encode_Chrono_Naive(DateTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_64(
        PlatformInt64Util.from(self.microsecondsSinceEpoch), serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb_Output_unit_AnyhowException(
          FutureOr<void> Function(SubrosaDb) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb_Output_unit_AnyhowException(
            self),
        serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord_Output_unit_AnyhowException(
          FutureOr<void> Function(List<HostRecord>) self,
          SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord_Output_unit_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartFn_Inputs_list_String_Output_bool_AnyhowException(
      FutureOr<bool> Function(List<String>) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_list_String_Output_bool_AnyhowException(self),
        serializer);
  }

  @protected
  void
      sse_encode_DartFn_Inputs_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession_Output_unit_AnyhowException(
          FutureOr<void> Function(SbSession?) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_DartOpaque(
        encode_DartFn_Inputs_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession_Output_unit_AnyhowException(
            self),
        serializer);
  }

  @protected
  void sse_encode_DartOpaque(Object self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_isize(
        PlatformPointerUtil.ptrToPlatformInt64(encodeDartOpaque(
            self, portManager.dartHandlerPort, generalizedFrbRustBinding)),
        serializer);
  }

  @protected
  void sse_encode_Map_String_list_prim_u_8_strict(
      Map<String, Uint8List> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_record_string_list_prim_u_8_strict(
        self.entries.map((e) => (e.key, e.value)).toList(), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerDartSyncFuturestaticSbResultSbSession(
          DartSyncFutureSbResultSbSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as DartSyncFutureSbResultSbSessionImpl)
            .frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          HostRecord self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as HostRecordImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
          Ipv4Addr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Ipv4AddrImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
          Ipv6Addr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as Ipv6AddrImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerMessageType(
          MessageType self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as MessageTypeImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          NewsGroup self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as NewsGroupImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
          PairingSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as PairingSessionImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          Parent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ParentImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerProtoUuid(
          ProtoUuid self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ProtoUuidImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          SbEvent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbEventImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResult(
          SbResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbResultImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbResultString(
          SbResultString self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbResultStringImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SbSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SbSessionImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerServiceScanner(
          ServiceScanner self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ServiceScannerImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaDb(
          SubrosaDb self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubrosaDbImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSubrosaMessage(
          SubrosaMessage self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as SubrosaMessageImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTryPairConfirm(
          TryPairConfirm self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as TryPairConfirmImpl).frbInternalSseEncode(move: null),
        serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerTypePrefix(
          TypePrefix self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as TypePrefixImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          Value self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as ValueImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void
      sse_encode_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerWatcher(
          Watcher self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_usize(
        (self as WatcherImpl).frbInternalSseEncode(move: null), serializer);
  }

  @protected
  void sse_encode_String(String self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(utf8.encoder.convert(self), serializer);
  }

  @protected
  void sse_encode_Uuid(UuidValue self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_list_prim_u_8_strict(self.toBytes(), serializer);
  }

  @protected
  void sse_encode_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self ? 1 : 0);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          NewsGroup self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          Parent self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
        self, serializer);
  }

  @protected
  void
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SbSession self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
        self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_Chrono_Naive(
      DateTime self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Chrono_Naive(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_bool(bool self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_bool(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_cached_identity(
      CachedIdentity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_cached_identity(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_crypto_config(
      CryptoConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_crypto_config(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_identity(
      Identity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_identity(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_message(Message self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_message(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_post_with_identity(
      PostWithIdentity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_post_with_identity(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_posts(Posts self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_posts(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_u_32(self, serializer);
  }

  @protected
  void sse_encode_box_autoadd_user(User self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_user(self, serializer);
  }

  @protected
  void sse_encode_cached_identity(
      CachedIdentity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Uuid(self.uuid, serializer);
    sse_encode_opt_Uuid(self.fingerprint, serializer);
    sse_encode_opt_String(self.userName, serializer);
    sse_encode_opt_String(self.bio, serializer);
    sse_encode_opt_box_autoadd_bool(self.owned, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.imageBytes, serializer);
  }

  @protected
  void sse_encode_crypto_config(CryptoConfig self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.secretkey, serializer);
    sse_encode_String(self.pubkey, serializer);
    sse_encode_opt_String(self.remotekey, serializer);
  }

  @protected
  void sse_encode_i_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putInt32(self);
  }

  @protected
  void sse_encode_i_64(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void sse_encode_identity(Identity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_Uuid(self.fingerprint, serializer);
    sse_encode_String(self.name, serializer);
    sse_encode_list_prim_u_8_strict(self.publicKey, serializer);
    sse_encode_bool(self.isOwned, serializer);
    sse_encode_Map_String_list_prim_u_8_strict(self.extra, serializer);
    sse_encode_list_prim_u_8_strict(self.sig, serializer);
  }

  @protected
  void sse_encode_import_identity_state(
      ImportIdentityState self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case ImportIdentityState_Initiated(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_Uuid(field0, serializer);
      case ImportIdentityState_Complete(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_Uuid(field0, serializer);
    }
  }

  @protected
  void sse_encode_ip_addr(IpAddr self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case IpAddr_V4(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv4Addr(
            field0, serializer);
      case IpAddr_V6(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerIpv6Addr(
            field0, serializer);
    }
  }

  @protected
  void sse_encode_isize(PlatformInt64 self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putPlatformInt64(self);
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          List<HostRecord> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerHostRecord(
          item, serializer);
    }
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          List<NewsGroup> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          item, serializer);
    }
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          List<SbEvent> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbEvent(
          item, serializer);
    }
  }

  @protected
  void
      sse_encode_list_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          List<Value> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerValue(
          item, serializer);
    }
  }

  @protected
  void sse_encode_list_String(List<String> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_String(item, serializer);
    }
  }

  @protected
  void sse_encode_list_identity(List<Identity> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_identity(item, serializer);
    }
  }

  @protected
  void sse_encode_list_ip_addr(List<IpAddr> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_ip_addr(item, serializer);
    }
  }

  @protected
  void sse_encode_list_message(List<Message> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_message(item, serializer);
    }
  }

  @protected
  void sse_encode_list_post_with_identity(
      List<PostWithIdentity> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_post_with_identity(item, serializer);
    }
  }

  @protected
  void sse_encode_list_posts(List<Posts> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_posts(item, serializer);
    }
  }

  @protected
  void sse_encode_list_prim_u_8_loose(
      List<int> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer
        .putUint8List(self is Uint8List ? self : Uint8List.fromList(self));
  }

  @protected
  void sse_encode_list_prim_u_8_strict(
      Uint8List self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    serializer.buffer.putUint8List(self);
  }

  @protected
  void sse_encode_list_record_string_list_prim_u_8_strict(
      List<(String, Uint8List)> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_record_string_list_prim_u_8_strict(item, serializer);
    }
  }

  @protected
  void sse_encode_list_user(List<User> self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.length, serializer);
    for (final item in self) {
      sse_encode_user(item, serializer);
    }
  }

  @protected
  void sse_encode_message(Message self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_Uuid(self.fromFingerprint, serializer);
    sse_encode_opt_Uuid(self.toFingerprint, serializer);
    sse_encode_String(self.application, serializer);
    sse_encode_String(self.extension_, serializer);
    sse_encode_String(self.mime, serializer);
    sse_encode_i_64(self.sendDate, serializer);
    sse_encode_i_64(self.receiveDate, serializer);
    sse_encode_bool(self.isFile, serializer);
    sse_encode_opt_Uuid(self.id, serializer);
    sse_encode_list_prim_u_8_strict(self.body, serializer);
    sse_encode_String(self.fileName, serializer);
  }

  @protected
  void sse_encode_on_conflict(OnConflict self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_i_32(self.index, serializer);
  }

  @protected
  void sse_encode_opt_String(String? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_String(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_Uuid(UuidValue? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_Uuid(self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          NewsGroup? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerNewsGroup(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          Parent? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerParent(
          self, serializer);
    }
  }

  @protected
  void
      sse_encode_opt_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          SbSession? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
          self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_Chrono_Naive(
      DateTime? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_Chrono_Naive(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_bool(bool? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_bool(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_i_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_i_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_u_32(int? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_u_32(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_box_autoadd_user(User? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_box_autoadd_user(self, serializer);
    }
  }

  @protected
  void sse_encode_opt_list_prim_u_8_strict(
      Uint8List? self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs

    sse_encode_bool(self != null, serializer);
    if (self != null) {
      sse_encode_list_prim_u_8_strict(self, serializer);
    }
  }

  @protected
  void sse_encode_pair_result(PairResult self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.remotekey, serializer);
    sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
        self.session, serializer);
  }

  @protected
  void sse_encode_pair_status(PairStatus self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    switch (self) {
      case PairStatus_Paired(field0: final field0):
        sse_encode_i_32(0, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerSbSession(
            field0, serializer);
      case PairStatus_NotPaired(field0: final field0):
        sse_encode_i_32(1, serializer);
        sse_encode_Auto_Owned_RustOpaque_flutter_rust_bridgefor_generatedRustAutoOpaqueInnerPairingSession(
            field0, serializer);
    }
  }

  @protected
  void sse_encode_post_with_identity(
      PostWithIdentity self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.author, serializer);
    sse_encode_opt_String(self.header, serializer);
    sse_encode_opt_String(self.body, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.sig, serializer);
    sse_encode_Chrono_Naive(self.receiveDate, serializer);
    sse_encode_Uuid(self.postId, serializer);
    sse_encode_opt_Uuid(self.identity, serializer);
    sse_encode_Uuid(self.parentGroup, serializer);
    sse_encode_bool(self.sent, serializer);
    sse_encode_opt_Uuid(self.fingerprint, serializer);
    sse_encode_opt_String(self.userName, serializer);
    sse_encode_opt_String(self.bio, serializer);
    sse_encode_opt_box_autoadd_bool(self.owned, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.imageBytes, serializer);
  }

  @protected
  void sse_encode_posts(Posts self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_opt_String(self.header, serializer);
    sse_encode_opt_String(self.body, serializer);
    sse_encode_opt_list_prim_u_8_strict(self.sig, serializer);
    sse_encode_Chrono_Naive(self.receiveDate, serializer);
    sse_encode_Uuid(self.postId, serializer);
    sse_encode_opt_Uuid(self.identity, serializer);
    sse_encode_Uuid(self.parentGroup, serializer);
    sse_encode_bool(self.sent, serializer);
  }

  @protected
  void sse_encode_record_string_list_prim_u_8_strict(
      (String, Uint8List) self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_String(self.$1, serializer);
    sse_encode_list_prim_u_8_strict(self.$2, serializer);
  }

  @protected
  void sse_encode_u_16(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint16(self);
  }

  @protected
  void sse_encode_u_32(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint32(self);
  }

  @protected
  void sse_encode_u_8(int self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putUint8(self);
  }

  @protected
  void sse_encode_unit(void self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
  }

  @protected
  void sse_encode_user(User self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    sse_encode_Uuid(self.identity, serializer);
    sse_encode_String(self.userName, serializer);
    sse_encode_String(self.bio, serializer);
    sse_encode_bool(self.owned, serializer);
    sse_encode_list_prim_u_8_strict(self.imageBytes, serializer);
  }

  @protected
  void sse_encode_usize(BigInt self, SseSerializer serializer) {
    // Codec=Sse (Serialization based), see doc to use other codecs
    serializer.buffer.putBigUint64(self);
  }
}

@sealed
class DartSyncFutureSbResultSbSessionImpl extends RustOpaque
    implements DartSyncFutureSbResultSbSession {
  // Not to be used by end users
  DartSyncFutureSbResultSbSessionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  DartSyncFutureSbResultSbSessionImpl.frbInternalSseDecode(
      BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount: RustLib.instance.api
        .rust_arc_increment_strong_count_DartSyncFutureSbResultSbSession,
    rustArcDecrementStrongCount: RustLib.instance.api
        .rust_arc_decrement_strong_count_DartSyncFutureSbResultSbSession,
    rustArcDecrementStrongCountPtr: RustLib.instance.api
        .rust_arc_decrement_strong_count_DartSyncFutureSbResultSbSessionPtr,
  );
}

@sealed
class HostRecordImpl extends RustOpaque implements HostRecord {
  // Not to be used by end users
  HostRecordImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  HostRecordImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_HostRecord,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_HostRecord,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_HostRecordPtr,
  );

  Future<SbSession?> connect({required CryptoConfig state}) =>
      RustLib.instance.api
          .scatterbrainApiMdnsHostRecordConnect(that: this, state: state);

  List<IpAddr> getAddrs() =>
      RustLib.instance.api.scatterbrainApiMdnsHostRecordGetAddrs(
        that: this,
      );

  String getName() => RustLib.instance.api.scatterbrainApiMdnsHostRecordGetName(
        that: this,
      );

  int getPort() => RustLib.instance.api.scatterbrainApiMdnsHostRecordGetPort(
        that: this,
      );

  Future<SbSession> pair(
          {required CryptoConfig state,
          required String appName,
          required FutureOr<bool> Function(List<String>) cb}) =>
      RustLib.instance.api.scatterbrainApiMdnsHostRecordPair(
          that: this, state: state, appName: appName, cb: cb);

  Future<PairStatus> tryPair(
          {required CryptoConfig state,
          required String appName,
          required FutureOr<void> Function(SbSession?) onConnect}) =>
      RustLib.instance.api.scatterbrainApiMdnsHostRecordTryPair(
          that: this, state: state, appName: appName, onConnect: onConnect);
}

@sealed
class Ipv4AddrImpl extends RustOpaque implements Ipv4Addr {
  // Not to be used by end users
  Ipv4AddrImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  Ipv4AddrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Ipv4Addr,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Ipv4Addr,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_Ipv4AddrPtr,
  );

  Future<bool> isLoopback() =>
      RustLib.instance.api.scatterbrainApiMdnsIpv4AddrIsLoopback(
        that: this,
      );

  Future<bool> isMulticast() =>
      RustLib.instance.api.scatterbrainApiMdnsIpv4AddrIsMulticast(
        that: this,
      );

  Future<bool> isUnspecified() =>
      RustLib.instance.api.scatterbrainApiMdnsIpv4AddrIsUnspecified(
        that: this,
      );

  String toString() => RustLib.instance.api.scatterbrainApiMdnsIpv4AddrToString(
        that: this,
      );
}

@sealed
class Ipv6AddrImpl extends RustOpaque implements Ipv6Addr {
  // Not to be used by end users
  Ipv6AddrImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  Ipv6AddrImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Ipv6Addr,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Ipv6Addr,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_Ipv6AddrPtr,
  );

  Future<bool> isLoopback() =>
      RustLib.instance.api.scatterbrainApiMdnsIpv6AddrIsLoopback(
        that: this,
      );

  Future<bool> isMulticast() =>
      RustLib.instance.api.scatterbrainApiMdnsIpv6AddrIsMulticast(
        that: this,
      );

  Future<bool> isUnspecified() =>
      RustLib.instance.api.scatterbrainApiMdnsIpv6AddrIsUnspecified(
        that: this,
      );

  String toString() => RustLib.instance.api.scatterbrainApiMdnsIpv6AddrToString(
        that: this,
      );
}

@sealed
class MessageTypeImpl extends RustOpaque implements MessageType {
  // Not to be used by end users
  MessageTypeImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  MessageTypeImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_MessageType,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_MessageType,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_MessageTypePtr,
  );
}

@sealed
class NewsGroupImpl extends RustOpaque implements NewsGroup {
  // Not to be used by end users
  NewsGroupImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  NewsGroupImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_NewsGroup,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_NewsGroup,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_NewsGroupPtr,
  );

  Parent asParent() => RustLib.instance.api.crateApiDbEntitiesNewsGroupAsParent(
        that: this,
      );

  String get description => RustLib.instance.api
          .crateApiDbEntitiesNewsGroupAutoAccessorGetDescription(
        that: this,
      );

  String get groupName =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorGetGroupName(
        that: this,
      );

  UuidValue? get parent =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorGetParent(
        that: this,
      );

  Uint8List? get parentHash =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorGetParentHash(
        that: this,
      );

  bool get sent =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorGetSent(
        that: this,
      );

  UuidValue get uuid =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorGetUuid(
        that: this,
      );

  set description(String description) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorSetDescription(
          that: this, description: description);

  set groupName(String groupName) =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorSetGroupName(
          that: this, groupName: groupName);

  set parent(UuidValue? parent) =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorSetParent(
          that: this, parent: parent);

  set parentHash(Uint8List? parentHash) =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupAutoAccessorSetParentHash(
          that: this, parentHash: parentHash);

  set sent(bool sent) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorSetSent(that: this, sent: sent);

  set uuid(UuidValue uuid) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupAutoAccessorSetUuid(that: this, uuid: uuid);

  Future<void> delete({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupDelete(that: this, conn: conn);

  Future<Uint8List> hash() =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupHash(
        that: this,
      );

  Future<void> insert({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupInsert(that: this, conn: conn);

  Future<void> insertOnConflict(
          {required SubrosaDb conn, required OnConflict onConflict}) =>
      RustLib.instance.api.crateApiDbEntitiesNewsGroupInsertOnConflict(
          that: this, conn: conn, onConflict: onConflict);

  Future<void> update({required SubrosaDb conn}) => RustLib.instance.api
      .crateApiDbEntitiesNewsGroupUpdate(that: this, conn: conn);
}

@sealed
class PairingSessionImpl extends RustOpaque implements PairingSession {
  // Not to be used by end users
  PairingSessionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  PairingSessionImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_PairingSession,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_PairingSession,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_PairingSessionPtr,
  );

  List<String> get coin =>
      RustLib.instance.api.scatterbrainApiApiPairingSessionAutoAccessorGetCoin(
        that: this,
      );

  UuidValue get session => RustLib.instance.api
          .scatterbrainApiApiPairingSessionAutoAccessorGetSession(
        that: this,
      );

  set coin(List<String> coin) =>
      RustLib.instance.api.scatterbrainApiApiPairingSessionAutoAccessorSetCoin(
          that: this, coin: coin);

  set session(UuidValue session) => RustLib.instance.api
      .scatterbrainApiApiPairingSessionAutoAccessorSetSession(
          that: this, session: session);

  Future<PairResult> tryPairConfirm({required bool accept}) =>
      RustLib.instance.api.scatterbrainApiApiPairingSessionTryPairConfirm(
          that: this, accept: accept);
}

@sealed
class ParentImpl extends RustOpaque implements Parent {
  // Not to be used by end users
  ParentImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ParentImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Parent,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Parent,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ParentPtr,
  );
}

@sealed
class ProtoUuidImpl extends RustOpaque implements ProtoUuid {
  // Not to be used by end users
  ProtoUuidImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ProtoUuidImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ProtoUuid,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ProtoUuid,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ProtoUuidPtr,
  );
}

@sealed
class SbEventImpl extends RustOpaque implements SbEvent {
  // Not to be used by end users
  SbEventImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SbEventImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SbEvent,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SbEvent,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SbEventPtr,
  );
}

@sealed
class SbResultImpl extends RustOpaque implements SbResult {
  // Not to be used by end users
  SbResultImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SbResultImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SbResult,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SbResult,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SbResultPtr,
  );
}

@sealed
class SbResultStringImpl extends RustOpaque implements SbResultString {
  // Not to be used by end users
  SbResultStringImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SbResultStringImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SbResultString,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SbResultString,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SbResultStringPtr,
  );
}

@sealed
class SbSessionImpl extends RustOpaque implements SbSession {
  // Not to be used by end users
  SbSessionImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SbSessionImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SbSession,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SbSession,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SbSessionPtr,
  );

  Future<void> disconnect() =>
      RustLib.instance.api.scatterbrainApiApiSbSessionDisconnect(
        that: this,
      );

  Future<List<SbEvent>> getEvents({required bool block, int? count}) =>
      RustLib.instance.api.scatterbrainApiApiSbSessionGetEvents(
          that: this, block: block, count: count);

  Future<List<Identity>> getIdentity({UuidValue? id}) => RustLib.instance.api
      .scatterbrainApiApiSbSessionGetIdentity(that: this, id: id);

  Future<List<Message>> getMessages(
          {required String application, int? limit}) =>
      RustLib.instance.api.scatterbrainApiApiSbSessionGetMessages(
          that: this, application: application, limit: limit);

  Future<List<Message>> getMessagesRecieveDate(
          {required String application,
          int? limit,
          DateTime? startDate,
          DateTime? endDate}) =>
      RustLib.instance.api.scatterbrainApiApiSbSessionGetMessagesRecieveDate(
          that: this,
          application: application,
          limit: limit,
          startDate: startDate,
          endDate: endDate);

  Future<List<Message>> getMessagesSendDate(
          {required String application,
          int? limit,
          DateTime? startDate,
          DateTime? endDate}) =>
      RustLib.instance.api.scatterbrainApiApiSbSessionGetMessagesSendDate(
          that: this,
          application: application,
          limit: limit,
          startDate: startDate,
          endDate: endDate);

  Future<ImportIdentityState> initiateIdentityImport({UuidValue? id}) => RustLib
      .instance.api
      .scatterbrainApiApiSbSessionInitiateIdentityImport(that: this, id: id);

  Future<bool> isClosed() =>
      RustLib.instance.api.scatterbrainApiApiSbSessionIsClosed(
        that: this,
      );

  Future<void> onConnect() =>
      RustLib.instance.api.scatterbrainApiApiSbSessionOnConnect(
        that: this,
      );

  Future<void> sendMessages(
          {required List<Message> messages, UuidValue? signIdentity}) =>
      RustLib.instance.api.scatterbrainApiApiSbSessionSendMessages(
          that: this, messages: messages, signIdentity: signIdentity);

  Future<void> sendNewsgroup({required NewsGroup newsgroup}) =>
      RustLib.instance.api.scatterbrainApiApiSbSessionSendNewsgroup(
          that: this, newsgroup: newsgroup);

  Future<void> sendPost({required Posts post, required SubrosaDb db}) =>
      RustLib.instance.api
          .scatterbrainApiApiSbSessionSendPost(that: this, post: post, db: db);

  Future<void> setOnConnect(
          {required FutureOr<void> Function(SbSession?) onConnect}) =>
      RustLib.instance.api.scatterbrainApiApiSbSessionSetOnConnect(
          that: this, onConnect: onConnect);
}

@sealed
class ServiceScannerImpl extends RustOpaque implements ServiceScanner {
  // Not to be used by end users
  ServiceScannerImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ServiceScannerImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_ServiceScanner,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_ServiceScanner,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ServiceScannerPtr,
  );

  Future<void> discoverDevices(
          {required FutureOr<void> Function(List<HostRecord>) cb}) =>
      RustLib.instance.api
          .scatterbrainApiMdnsServiceScannerDiscoverDevices(that: this, cb: cb);

  Future<void> stopScan() =>
      RustLib.instance.api.scatterbrainApiMdnsServiceScannerStopScan(
        that: this,
      );
}

@sealed
class SubrosaDbImpl extends RustOpaque implements SubrosaDb {
  // Not to be used by end users
  SubrosaDbImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SubrosaDbImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SubrosaDb,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubrosaDb,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubrosaDbPtr,
  );

  Future<void> deleteGroup({required UuidValue uuid}) => RustLib.instance.api
      .crateApiDbConnectionSubrosaDbDeleteGroup(that: this, uuid: uuid);

  Future<void> deletePost({required UuidValue uuid}) => RustLib.instance.api
      .crateApiDbConnectionSubrosaDbDeletePost(that: this, uuid: uuid);

  Future<List<User>> getAllUsers() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetAllUsers(
        that: this,
      );

  Future<List<User>> getAllUsersByOwnership({required bool owned}) =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetAllUsersByOwnership(
          that: this, owned: owned);

  Future<void> getConnection() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetConnection(
        that: this,
      );

  Future<NewsGroup?> getGroup({required UuidValue uuid}) => RustLib.instance.api
      .crateApiDbConnectionSubrosaDbGetGroup(that: this, uuid: uuid);

  Future<List<NewsGroup>> getGroupsForParent({required UuidValue parent}) =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetGroupsForParent(
          that: this, parent: parent);

  Future<CachedIdentity> getIdentity({required UuidValue uuid}) =>
      RustLib.instance.api
          .crateApiDbConnectionSubrosaDbGetIdentity(that: this, uuid: uuid);

  Future<DateTime?> getLastSyncDate() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetLastSyncDate(
        that: this,
      );

  Future<List<NewsGroup>> getParents({required UuidValue group}) =>
      RustLib.instance.api
          .crateApiDbConnectionSubrosaDbGetParents(that: this, group: group);

  Future<List<Posts>> getPosts({required UuidValue parent}) =>
      RustLib.instance.api
          .crateApiDbConnectionSubrosaDbGetPosts(that: this, parent: parent);

  Future<List<PostWithIdentity>> getPostsWithIdentity(
          {required UuidValue parent}) =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetPostsWithIdentity(
          that: this, parent: parent);

  Future<List<NewsGroup>> getRootGroups() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetRootGroups(
        that: this,
      );

  Future<PlatformInt64> getTotalPosts({required UuidValue group}) =>
      RustLib.instance.api
          .crateApiDbConnectionSubrosaDbGetTotalPosts(that: this, group: group);

  Future<List<NewsGroup>> getUnsentGroups() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetUnsentGroups(
        that: this,
      );

  Future<List<Posts>> getUnsentPosts() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetUnsentPosts(
        that: this,
      );

  Future<User?> getUser({required UuidValue identity}) => RustLib.instance.api
      .crateApiDbConnectionSubrosaDbGetUser(that: this, identity: identity);

  Watcher getWatcher() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbGetWatcher(
        that: this,
      );

  Future<void> insertGroup({required NewsGroup group}) => RustLib.instance.api
      .crateApiDbConnectionSubrosaDbInsertGroup(that: this, group: group);

  Future<void> insertMessage({required Message message}) => RustLib.instance.api
      .crateApiDbConnectionSubrosaDbInsertMessage(that: this, message: message);

  Future<void> markSentGroups({required List<Value> ids}) =>
      RustLib.instance.api
          .crateApiDbConnectionSubrosaDbMarkSentGroups(that: this, ids: ids);

  Future<void> markSentPosts({required List<Value> ids}) => RustLib.instance.api
      .crateApiDbConnectionSubrosaDbMarkSentPosts(that: this, ids: ids);

  Future<void> processScatterMessages({required List<Message> messages}) =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbProcessScatterMessages(
          that: this, messages: messages);

  Future<void> sync_({required SbSession sbConnection}) =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbSync(
          that: this, sbConnection: sbConnection);

  Future<List<NewsGroup>> test({required UuidValue uuid}) =>
      RustLib.instance.api
          .crateApiDbConnectionSubrosaDbTest(that: this, uuid: uuid);

  Future<NewsGroup?> testNullable() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbTestNullable(
        that: this,
      );

  Future<NewsGroup> testOne() =>
      RustLib.instance.api.crateApiDbConnectionSubrosaDbTestOne(
        that: this,
      );
}

@sealed
class SubrosaMessageImpl extends RustOpaque implements SubrosaMessage {
  // Not to be used by end users
  SubrosaMessageImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  SubrosaMessageImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_SubrosaMessage,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubrosaMessage,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_SubrosaMessagePtr,
  );

  Future<Message> getMessage() =>
      RustLib.instance.api.crateApiProtoSerSubrosaMessageGetMessage(
        that: this,
      );
}

@sealed
class TryPairConfirmImpl extends RustOpaque implements TryPairConfirm {
  // Not to be used by end users
  TryPairConfirmImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  TryPairConfirmImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_TryPairConfirm,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_TryPairConfirm,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_TryPairConfirmPtr,
  );
}

@sealed
class TypePrefixImpl extends RustOpaque implements TypePrefix {
  // Not to be used by end users
  TypePrefixImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  TypePrefixImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_TypePrefix,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_TypePrefix,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_TypePrefixPtr,
  );
}

@sealed
class ValueImpl extends RustOpaque implements Value {
  // Not to be used by end users
  ValueImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  ValueImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Value,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Value,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_ValuePtr,
  );
}

@sealed
class WatcherImpl extends RustOpaque implements Watcher {
  // Not to be used by end users
  WatcherImpl.frbInternalDcoDecode(List<dynamic> wire)
      : super.frbInternalDcoDecode(wire, _kStaticData);

  // Not to be used by end users
  WatcherImpl.frbInternalSseDecode(BigInt ptr, int externalSizeOnNative)
      : super.frbInternalSseDecode(ptr, externalSizeOnNative, _kStaticData);

  static final _kStaticData = RustArcStaticData(
    rustArcIncrementStrongCount:
        RustLib.instance.api.rust_arc_increment_strong_count_Watcher,
    rustArcDecrementStrongCount:
        RustLib.instance.api.rust_arc_decrement_strong_count_Watcher,
    rustArcDecrementStrongCountPtr:
        RustLib.instance.api.rust_arc_decrement_strong_count_WatcherPtr,
  );

  Future<void> watch(
          {required String table,
          required FutureOr<void> Function(SubrosaDb) cb}) =>
      RustLib.instance.api
          .crateApiDbConnectionWatcherWatch(that: this, table: table, cb: cb);
}
